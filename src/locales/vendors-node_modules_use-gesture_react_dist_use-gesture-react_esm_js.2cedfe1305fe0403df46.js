(self["webpackChunkreact_advanced"] = self["webpackChunkreact_advanced"] || []).push([["vendors-node_modules_use-gesture_react_dist_use-gesture-react_esm_js"],{

/***/ "./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigResolverMap": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.C; },
/* harmony export */   "EngineMap": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.E; },
/* harmony export */   "dragAction": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.e; },
/* harmony export */   "hoverAction": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.h; },
/* harmony export */   "moveAction": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.m; },
/* harmony export */   "pinchAction": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.f; },
/* harmony export */   "registerAction": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.r; },
/* harmony export */   "scrollAction": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.s; },
/* harmony export */   "wheelAction": function() { return /* reexport safe */ _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.w; }
/* harmony export */ });
/* harmony import */ var _dist_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/actions-76b8683e.esm.js */ "./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js");




/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C": function() { return /* binding */ ConfigResolverMap; },
/* harmony export */   "E": function() { return /* binding */ EngineMap; },
/* harmony export */   "S": function() { return /* binding */ SUPPORT; },
/* harmony export */   "_": function() { return /* binding */ _objectSpread2; },
/* harmony export */   "a": function() { return /* binding */ _defineProperty; },
/* harmony export */   "b": function() { return /* binding */ touchIds; },
/* harmony export */   "c": function() { return /* binding */ chain; },
/* harmony export */   "d": function() { return /* binding */ toHandlerProp; },
/* harmony export */   "e": function() { return /* binding */ dragAction; },
/* harmony export */   "f": function() { return /* binding */ pinchAction; },
/* harmony export */   "h": function() { return /* binding */ hoverAction; },
/* harmony export */   "i": function() { return /* binding */ isTouch; },
/* harmony export */   "m": function() { return /* binding */ moveAction; },
/* harmony export */   "p": function() { return /* binding */ parseProp; },
/* harmony export */   "r": function() { return /* binding */ registerAction; },
/* harmony export */   "s": function() { return /* binding */ scrollAction; },
/* harmony export */   "t": function() { return /* binding */ toDomEventType; },
/* harmony export */   "w": function() { return /* binding */ wheelAction; }
/* harmony export */ });
/* harmony import */ var _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./maths-0ab39ae9.esm.js */ "./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js");


function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

const EVENT_TYPE_MAP = {
  pointer: {
    start: 'down',
    change: 'move',
    end: 'up'
  },
  mouse: {
    start: 'down',
    change: 'move',
    end: 'up'
  },
  touch: {
    start: 'start',
    change: 'move',
    end: 'end'
  },
  gesture: {
    start: 'start',
    change: 'change',
    end: 'end'
  }
};
function capitalize(string) {
  if (!string) return '';
  return string[0].toUpperCase() + string.slice(1);
}
const actionsWithoutCaptureSupported = ['enter', 'leave'];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = '', capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return 'on' + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? 'Capture' : '');
}
const pointerCaptureEvents = ['gotpointercapture', 'lostpointercapture'];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf('passive');
  if (passive) eventKey = eventKey.replace('passive', '');
  const captureKey = pointerCaptureEvents.includes(eventKey) ? 'capturecapture' : 'capture';
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace('capture', '');
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = '') {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return 'touches' in event;
}
function getPointerType(event) {
  if (isTouch(event)) return 'touch';
  if ('pointerType' in event) return event.pointerType;
  return 'mouse';
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter(e => {
    var _event$currentTarget, _event$currentTarget$;
    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}
function getTouchList(event) {
  return event.type === 'touchend' || event.type === 'touchcancel' ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {}
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map(touch => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter(touch => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ('buttons' in event) payload.buttons = event.buttons;
  if ('shiftKey' in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}

function call(v, ...args) {
  if (typeof v === 'function') {
    return v(...args);
  } else {
    return v;
  }
}
function noop() {}
function chain(...fns) {
  if (fns.length === 0) return noop;
  if (fns.length === 1) return fns[0];
  return function () {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}

const BEFORE_LAST_KINEMATICS_DELAY = 32;
class Engine {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = undefined;
    state.memo = undefined;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config.from ? call(config.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values) {
    const state = this.state;
    state._values = values;
    state.values = this.config.transform(values);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config.threshold;
    const {
      _step,
      values
    } = state;
    if (config.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config.hasCustomTransform) {
      const [v0, v1] = values;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ('bounds' in config) state._bounds = call(config.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband = state._active ? config.rubberband || [0, 0] : [0, 0];
    state.offset = (0,_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(state._bounds, state.offset, rubberband);
    state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents) return;
    const memo = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo !== undefined) state.memo = memo;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
}

function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return 'x';
  }
  if (absDy > absDx && absDy > threshold) {
    return 'y';
  }
  return undefined;
}
class CoordinatesEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "aliasKey", 'xy');
  }
  reset() {
    super.reset();
    this.state.axis = undefined;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config = this.config;
    if (!state.axis && event) {
      const threshold = typeof config.axisThreshold === 'object' ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case 'x':
          v[1] = 0;
          break;
        case 'y':
          v[0] = 0;
          break;
      }
    }
  }
}

const identity = v => v;
const DEFAULT_RUBBERBAND = 0.15;
const commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config) {
    return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === 'function') return value;
    if (value != null) return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value);
  },
  transform(value, _k, config) {
    const transform = value || config.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return v => {
        const r = originalTransform(v);
        if (!isFinite(r[0]) || !isFinite(r[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r[0]},${[1]}]`);
        }
        return r;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}

const DEFAULT_AXIS_THRESHOLD = 0;
const coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === 'lock';
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === 'function') {
      return state => coordinatesConfigResolver.bounds(value(state));
    }
    if ('current' in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === 'function' && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});

const KEYS_DELTA_MAP = {
  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
};
class DragEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", 'dragging');
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = undefined;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config.pointerButtons) ? !config.pointerButtons.includes(event.buttons) : config.pointerButtons !== -1 && config.pointerButtons !== event.buttons)) return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config.preventScrollAxis && getPointerType(event) !== 'mouse') {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config.delay > 0) {
      this.setupDelayTrigger(event);
      if (config.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config = this.config;
    if (!state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== undefined && id !== state._pointerId) return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(_values, state._values);
      this.computeValues(_values);
    }
    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove('dragDelay');
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config.preventScrollAxis || config.preventScrollAxis === 'xy') {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove('startPointerDrag');
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. \n\nPlease upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config = this.config;
    if (!state._active || !state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== undefined && id !== state._pointerId) return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config.tapsThreshold && dy <= config.tapsThreshold;
    if (state.tap && config.filterTaps) {
      state._force = true;
    } else {
      const [_dx, _dy] = state._delta;
      const [_mx, _my] = state._movement;
      const [svx, svy] = config.swipe.velocity;
      const [sx, sy] = config.swipe.distance;
      const sdt = config.swipe.duration;
      if (state.elapsedTime < sdt) {
        const _vx = Math.abs(_dx / state.timeDelta);
        const _vy = Math.abs(_dy / state.timeDelta);
        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);
        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config = this.config;
    const device = config.device;
    if (true) {
      try {
        if (device === 'pointer' && config.preventScrollDelay === undefined) {
          const currentTarget = 'uv' in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === 'auto') {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {}
    }
    if (config.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, 'change', this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, 'end', this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, 'cancel', this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, 'touch', 'change', this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, 'touch', 'end', remove);
    this.eventStore.add(this.sharedConfig.window, 'touch', 'cancel', remove);
    this.timeoutStore.add('startPointerDrag', this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add('dragDelay', () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(this.config.keyboardDisplacement, factor);
      state._keyboardActive = true;
      _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP)) return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, 'start', this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, 'change', this.pointerMove.bind(this));
      bindFunction(device, 'end', this.pointerUp.bind(this));
      bindFunction(device, 'cancel', this.pointerUp.bind(this));
      bindFunction('lostPointerCapture', '', this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction('key', 'down', this.keyDown.bind(this));
      bindFunction('key', 'up', this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction('click', '', this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
}
function persistEvent(event) {
  'persist' in event && typeof event.persist === 'function' && event.persist();
}

const isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && 'ontouchstart' in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && 'onpointerdown' in window;
}
function supportsPointerLock() {
  return isBrowser && 'exitPointerLock' in window.document;
}
function supportsGestureEvents() {
  try {
    return 'constructor' in GestureEvent;
  } catch (e) {
    return false;
  }
}
const SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: isTouchScreen(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};

const DEFAULT_PREVENT_SCROLL_DELAY = 250;
const DEFAULT_DRAG_DELAY = 180;
const DEFAULT_SWIPE_VELOCITY = 0.5;
const DEFAULT_SWIPE_DISTANCE = 50;
const DEFAULT_SWIPE_DURATION = 250;
const DEFAULT_KEYBOARD_DISPLACEMENT = 10;
const DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
const dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return 'touch';
    if (this.pointerLock) return 'mouse';
    if (SUPPORT.pointer && !mouse) return 'pointer';
    if (SUPPORT.touch) return 'touch';
    return 'mouse';
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === 'number' ? preventScroll : preventScroll || preventScroll === undefined && value ? DEFAULT_PREVENT_SCROLL_DELAY : undefined;
    if (!SUPPORT.touchscreen || preventScroll === false) return undefined;
    return value ? value : preventScroll !== undefined ? 'y' : undefined;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === 'pointer' && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = undefined
  }) {
    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(velocity)),
      distance: this.transform(_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== undefined) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}

function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}

const SCALE_ANGLE_RATIO_INTENT_DEG = 30;
const PINCH_WHEEL_RATIO = 100;
class PinchEngine extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", 'pinching');
    _defineProperty(this, "aliasKey", 'da');
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === 'wheel') {
      this.state.offset = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = 'angle';else if (axisMovementDifference > 0) state.axis = 'scale';
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === 'scale') v[1] = 0;else if (this.state.axis === 'angle') v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every(id => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every(id => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some(id => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {}
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && !event[modifierKey]) return;
    if (!this.state._active) this.wheelStart(event);else this.wheelChange(event);
    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = ('uv' in event);
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if ( true && !event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.\n\nThis message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, 'start', this[device + 'Start'].bind(this));
      bindFunction(device, 'change', this[device + 'Move'].bind(this));
      bindFunction(device, 'end', this[device + 'End'].bind(this));
      bindFunction(device, 'cancel', this[device + 'End'].bind(this));
      bindFunction('lostPointerCapture', '', this[device + 'End'].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction('wheel', '', this.wheel.bind(this), {
        passive: false
      });
    }
  }
}

const pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return 'gesture';
    if (SUPPORT.touch && touch) return 'touch';
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return 'pointer';
      if (SUPPORT.touch) return 'touch';
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = state => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = state => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== 'function' && typeof angleBounds !== 'function') return [_scaleBounds(), _angleBounds()];
    return state => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config) {
    this.lockDirection = config.axis === 'lock';
    const threshold = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === undefined) return 'ctrlKey';
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});

class MoveEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", 'moving');
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;
    if (!this.state._active) this.moveStart(event);else this.moveChange(event);
    this.timeoutStore.add('moveEnd', this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active) return;
    const values = pointerValues(event);
    const state = this.state;
    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);
    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction('pointer', 'change', this.move.bind(this));
    bindFunction('pointer', 'leave', this.moveEnd.bind(this));
  }
}

const moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});

class ScrollEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", 'scrolling');
  }
  scroll(event) {
    if (!this.state._active) this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add('scrollEnd', this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    const values = scrollValues(event);
    state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);
    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);
    this.computeValues(values);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction('scroll', '', this.scroll.bind(this));
  }
}

const scrollConfigResolver = coordinatesConfigResolver;

class WheelEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", 'wheeling');
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add('wheelEnd', this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction('wheel', '', this.wheel.bind(this));
  }
}

const wheelConfigResolver = coordinatesConfigResolver;

class HoverEngine extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "ingKey", 'hovering');
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== 'mouse') return;
    const state = this.state;
    if (!state._active) return;
    state._active = false;
    const values = pointerValues(event);
    state._movement = state._delta = _maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.V.sub(values, state._values);
    this.computeValues(values);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction('pointer', 'enter', this.enter.bind(this));
    bindFunction('pointer', 'leave', this.leave.bind(this));
  }
}

const hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});

const EngineMap = new Map();
const ConfigResolverMap = new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
const dragAction = {
  key: 'drag',
  engine: DragEngine,
  resolver: dragConfigResolver
};
const hoverAction = {
  key: 'hover',
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
const moveAction = {
  key: 'move',
  engine: MoveEngine,
  resolver: moveConfigResolver
};
const pinchAction = {
  key: 'pinch',
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
const scrollAction = {
  key: 'scroll',
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
const wheelAction = {
  key: 'wheel',
  engine: WheelEngine,
  resolver: wheelConfigResolver
};




/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "V": function() { return /* binding */ V; },
/* harmony export */   "c": function() { return /* binding */ computeRubberband; },
/* harmony export */   "r": function() { return /* binding */ rubberbandIfOutOfBounds; }
/* harmony export */ });
function clamp(v, min, max) {
  return Math.max(min, Math.min(v, max));
}
const V = {
  toVector(v, fallback) {
    if (v === undefined) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
  if (constant === 0) return clamp(position, min, max);
  if (position < min) return -rubberband(min - position, max - min, constant) + min;
  if (position > max) return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}




/***/ }),

/***/ "./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Controller": function() { return /* binding */ Controller; },
/* harmony export */   "parseMergedHandlers": function() { return /* binding */ parseMergedHandlers; }
/* harmony export */ });
/* harmony import */ var _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actions-76b8683e.esm.js */ "./node_modules/@use-gesture/core/dist/actions-76b8683e.esm.js");



function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}

const sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => 'current' in value ? value.current : value;
    }
    return undefined;
  },
  enabled(value = true) {
    return value;
  },
  window(value = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.S.isBrowser ? window : undefined) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};

const _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case 'function':
        if (true) {
          const r = resolver.call(result, config[key], key, config);
          if (!Number.isNaN(r)) result[key] = r;
        } else {}
        break;
      case 'object':
        result[key] = resolveWith(config[key], resolver);
        break;
      case 'boolean':
        if (resolver) result[key] = config[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig,
    {
      target,
      eventOptions,
      window,
      enabled,
      transform
    } = _ref,
    rest = _objectWithoutProperties(_ref, _excluded);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(gestureKey);
    _config[gestureKey] = resolveWith((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.C.get(key);
      if (resolver) {
        _config[key] = resolveWith((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!['drag', 'pinch', 'scroll', 'wheel', 'move', 'hover'].includes(key)) {
          if (key === 'domTarget') {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}

class EventStore {
  constructor(ctrl, gestureKey) {
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "_listeners", new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach(remove => remove());
    this._listeners.clear();
  }
}

class TimeoutStore {
  constructor() {
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "_timeouts", new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout = this._timeouts.get(key);
    if (timeout) window.clearTimeout(timeout);
  }
  clean() {
    this._timeouts.forEach(timeout => void window.clearTimeout(timeout));
    this._timeouts.clear();
  }
}

class Controller {
  constructor(handlers) {
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "gestures", new Set());
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "_targetEventStore", new EventStore(this));
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "gestureEventStores", {});
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "gestureTimeoutStores", {});
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "handlers", {});
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "config", {});
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "pointerIds", new Set());
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "touchIds", new Set());
    (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if ((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(event)) {
      this.touchIds = new Set((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(event));
      return this.touchIds;
    } else if ('pointerId' in event) {
      if (event.type === 'pointerup' || event.type === 'pointercancel') this.pointerIds.delete(event.pointerId);else if (event.type === 'pointerdown') this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config, gestureKey) {
    this.config = parse(config, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine = _actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.get(gestureKey);
          new Engine(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, '', event => this.nativeHandlers[eventKey]((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, this.state.shared), {}, {
          event,
          args
        })), undefined, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.p)(handlerProp);
      this._targetEventStore.add(target, device, '', props[handlerProp], {
        capture,
        passive
      });
    }
  }
}
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, 'drag');
  if (internalHandlers.wheel) setupGesture(ctrl, 'wheel');
  if (internalHandlers.scroll) setupGesture(ctrl, 'scroll');
  if (internalHandlers.move) setupGesture(ctrl, 'move');
  if (internalHandlers.pinch) setupGesture(ctrl, 'pinch');
  if (internalHandlers.hover) setupGesture(ctrl, 'hover');
}
const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : (0,_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(device, action, capture);
  if (withPassiveOption && passive) handlerProp += 'Passive';
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};

const RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
  if (!actions.has(handlerKey)) return;
  if (!_actions_76b8683e_esm_js__WEBPACK_IMPORTED_MODULE_0__.E.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.\n\nPlease add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + 'Start';
  const endKey = handlerKey + 'End';
  const fn = state => {
    let memo = undefined;
    if (state.first && startKey in handlers) handlers[startKey](state);
    if (handlerKey in handlers) memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers) handlers[endKey](state);
    return memo;
  };
  internalHandlers[key] = fn;
  config[key] = config[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, 'onDrag', 'drag', internalHandlers, mergedConfig);
  registerGesture(actions, handlers, 'onWheel', 'wheel', internalHandlers, mergedConfig);
  registerGesture(actions, handlers, 'onScroll', 'scroll', internalHandlers, mergedConfig);
  registerGesture(actions, handlers, 'onPinch', 'pinch', internalHandlers, mergedConfig);
  registerGesture(actions, handlers, 'onMove', 'move', internalHandlers, mergedConfig);
  registerGesture(actions, handlers, 'onHover', 'hover', internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}




/***/ }),

/***/ "./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js ***!
  \*********************************************************************************/
/***/ (function() {




/***/ }),

/***/ "./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rubberbandIfOutOfBounds": function() { return /* reexport safe */ _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__.r; }
/* harmony export */ });
/* harmony import */ var _dist_maths_0ab39ae9_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/maths-0ab39ae9.esm.js */ "./node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js");



/***/ }),

/***/ "./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConfigResolverMap": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.ConfigResolverMap; },
/* harmony export */   "EngineMap": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.EngineMap; },
/* harmony export */   "createUseGesture": function() { return /* binding */ createUseGesture; },
/* harmony export */   "dragAction": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.dragAction; },
/* harmony export */   "hoverAction": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.hoverAction; },
/* harmony export */   "moveAction": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.moveAction; },
/* harmony export */   "pinchAction": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.pinchAction; },
/* harmony export */   "registerAction": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction; },
/* harmony export */   "rubberbandIfOutOfBounds": function() { return /* reexport safe */ _use_gesture_core_utils__WEBPACK_IMPORTED_MODULE_2__.rubberbandIfOutOfBounds; },
/* harmony export */   "scrollAction": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.scrollAction; },
/* harmony export */   "useDrag": function() { return /* binding */ useDrag; },
/* harmony export */   "useGesture": function() { return /* binding */ useGesture; },
/* harmony export */   "useHover": function() { return /* binding */ useHover; },
/* harmony export */   "useMove": function() { return /* binding */ useMove; },
/* harmony export */   "usePinch": function() { return /* binding */ usePinch; },
/* harmony export */   "useScroll": function() { return /* binding */ useScroll; },
/* harmony export */   "useWheel": function() { return /* binding */ useWheel; },
/* harmony export */   "wheelAction": function() { return /* reexport safe */ _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.wheelAction; }
/* harmony export */ });
/* harmony import */ var _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @use-gesture/core/actions */ "./node_modules/@use-gesture/core/actions/dist/use-gesture-core-actions.esm.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _use_gesture_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @use-gesture/core */ "./node_modules/@use-gesture/core/dist/use-gesture-core.esm.js");
/* harmony import */ var _use_gesture_core_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @use-gesture/core/utils */ "./node_modules/@use-gesture/core/utils/dist/use-gesture-core-utils.esm.js");
/* harmony import */ var _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @use-gesture/core/types */ "./node_modules/@use-gesture/core/types/dist/use-gesture-core-types.esm.js");
/* harmony import */ var _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__) if(["default","createUseGesture","useDrag","useGesture","useHover","useMove","usePinch","useScroll","useWheel","ConfigResolverMap","EngineMap","dragAction","hoverAction","moveAction","pinchAction","registerAction","scrollAction","wheelAction","rubberbandIfOutOfBounds"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _use_gesture_core_types__WEBPACK_IMPORTED_MODULE_3__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);







function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
  const ctrl = react__WEBPACK_IMPORTED_MODULE_1___default().useMemo(() => new _use_gesture_core__WEBPACK_IMPORTED_MODULE_4__.Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config, gestureKey);
  react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(ctrl.effect.bind(ctrl));
  react__WEBPACK_IMPORTED_MODULE_1___default().useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config.target === undefined) {
    return ctrl.bind.bind(ctrl);
  }
  return undefined;
}

function useDrag(handler, config) {
  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.dragAction);
  return useRecognizers({
    drag: handler
  }, config || {}, 'drag');
}

function usePinch(handler, config) {
  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.pinchAction);
  return useRecognizers({
    pinch: handler
  }, config || {}, 'pinch');
}

function useWheel(handler, config) {
  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.wheelAction);
  return useRecognizers({
    wheel: handler
  }, config || {}, 'wheel');
}

function useScroll(handler, config) {
  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.scrollAction);
  return useRecognizers({
    scroll: handler
  }, config || {}, 'scroll');
}

function useMove(handler, config) {
  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.moveAction);
  return useRecognizers({
    move: handler
  }, config || {}, 'move');
}

function useHover(handler, config) {
  (0,_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction)(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.hoverAction);
  return useRecognizers({
    hover: handler
  }, config || {}, 'hover');
}

function createUseGesture(actions) {
  actions.forEach(_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.registerAction);
  return function useGesture(_handlers, _config) {
    const {
      handlers,
      nativeHandlers,
      config
    } = (0,_use_gesture_core__WEBPACK_IMPORTED_MODULE_4__.parseMergedHandlers)(_handlers, _config || {});
    return useRecognizers(handlers, config, undefined, nativeHandlers);
  };
}

function useGesture(handlers, config) {
  const hook = createUseGesture([_use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.dragAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.pinchAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.scrollAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.wheelAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.moveAction, _use_gesture_core_actions__WEBPACK_IMPORTED_MODULE_0__.hoverAction]);
  return hook(handlers, config || {});
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdXNlLWdlc3R1cmVfcmVhY3RfZGlzdF91c2UtZ2VzdHVyZS1yZWFjdF9lc21fanMuMmNlZGZlMTMwNWZlMDQwM2RmNDYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0TjtBQUNsTDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0QwQjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQU87QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQWlCO0FBQ3BDLGtCQUFrQix5REFBSztBQUN2QjtBQUNBO0FBQ0Esb0JBQW9CLHlEQUFLO0FBQ3pCO0FBQ0EsTUFBTSwyREFBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUscUJBQXFCO0FBQ2xHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlEQUFLO0FBQzdCO0FBQ0E7QUFDQSwwQkFBMEIseURBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMkNBQTJDO0FBQzNDLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUFVO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4QkFBOEIsOERBQVU7QUFDeEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsS0FBSyxHQUFHLElBQUk7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsOERBQVU7QUFDckI7QUFDQTtBQUNBLElBQUksSUFBc0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4R0FBOEcsY0FBYztBQUM1SDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGtFQUFrRSwyQkFBMkI7QUFDN0Y7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQix5REFBSztBQUMxQjtBQUNBO0FBQ0EsSUFBSSwyREFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixVQUFVLElBQXNDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJEQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQ0FBZ0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsOERBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQSwrQkFBK0IsOERBQVU7QUFDekMsK0JBQStCLDhEQUFVO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxJQUFJLElBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlIQUFpSCxXQUFXLGVBQWU7QUFDM0k7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1SEFBdUgsU0FBUyxpQkFBaUI7QUFDako7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUhBQXVILFNBQVMsZ0JBQWdCO0FBQ2hKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVIQUF1SCxTQUFTLGlCQUFpQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEJBQTBCLHlEQUFLO0FBQy9CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5REFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyREFBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LEVBQUUseUVBQWMsQ0FBQyxrRUFBVztBQUM1QjtBQUNBO0FBQ0EsR0FBRyxjQUFjO0FBQ2pCOztBQUVBO0FBQ0Esa0JBQWtCLHFFQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsc0VBQW1CLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaUVBQVUsRUFBRSxrRUFBVyxFQUFFLG1FQUFZLEVBQUUsa0VBQVcsRUFBRSxpRUFBVSxFQUFFLGtFQUFXO0FBQzVHLG9DQUFvQztBQUNwQzs7QUFFbUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1hZHZhbmNlZC8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS9hY3Rpb25zL2Rpc3QvdXNlLWdlc3R1cmUtY29yZS1hY3Rpb25zLmVzbS5qcyIsIndlYnBhY2s6Ly9yZWFjdC1hZHZhbmNlZC8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS9kaXN0L2FjdGlvbnMtNzZiODY4M2UuZXNtLmpzIiwid2VicGFjazovL3JlYWN0LWFkdmFuY2VkLy4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9jb3JlL2Rpc3QvbWF0aHMtMGFiMzlhZTkuZXNtLmpzIiwid2VicGFjazovL3JlYWN0LWFkdmFuY2VkLy4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9jb3JlL2Rpc3QvdXNlLWdlc3R1cmUtY29yZS5lc20uanMiLCJ3ZWJwYWNrOi8vcmVhY3QtYWR2YW5jZWQvLi9ub2RlX21vZHVsZXMvQHVzZS1nZXN0dXJlL2NvcmUvdHlwZXMvZGlzdC91c2UtZ2VzdHVyZS1jb3JlLXR5cGVzLmVzbS5qcyIsIndlYnBhY2s6Ly9yZWFjdC1hZHZhbmNlZC8uL25vZGVfbW9kdWxlcy9AdXNlLWdlc3R1cmUvY29yZS91dGlscy9kaXN0L3VzZS1nZXN0dXJlLWNvcmUtdXRpbHMuZXNtLmpzIiwid2VicGFjazovL3JlYWN0LWFkdmFuY2VkLy4vbm9kZV9tb2R1bGVzL0B1c2UtZ2VzdHVyZS9yZWFjdC9kaXN0L3VzZS1nZXN0dXJlLXJlYWN0LmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDIGFzIENvbmZpZ1Jlc29sdmVyTWFwLCBFIGFzIEVuZ2luZU1hcCwgZSBhcyBkcmFnQWN0aW9uLCBoIGFzIGhvdmVyQWN0aW9uLCBtIGFzIG1vdmVBY3Rpb24sIGYgYXMgcGluY2hBY3Rpb24sIHIgYXMgcmVnaXN0ZXJBY3Rpb24sIHMgYXMgc2Nyb2xsQWN0aW9uLCB3IGFzIHdoZWVsQWN0aW9uIH0gZnJvbSAnLi4vLi4vZGlzdC9hY3Rpb25zLTc2Yjg2ODNlLmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rpc3QvbWF0aHMtMGFiMzlhZTkuZXNtLmpzJztcbiIsImltcG9ydCB7IFYsIGMgYXMgY29tcHV0ZVJ1YmJlcmJhbmQgfSBmcm9tICcuL21hdGhzLTBhYjM5YWU5LmVzbS5qcyc7XG5cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBFVkVOVF9UWVBFX01BUCA9IHtcbiAgcG9pbnRlcjoge1xuICAgIHN0YXJ0OiAnZG93bicsXG4gICAgY2hhbmdlOiAnbW92ZScsXG4gICAgZW5kOiAndXAnXG4gIH0sXG4gIG1vdXNlOiB7XG4gICAgc3RhcnQ6ICdkb3duJyxcbiAgICBjaGFuZ2U6ICdtb3ZlJyxcbiAgICBlbmQ6ICd1cCdcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICBzdGFydDogJ3N0YXJ0JyxcbiAgICBjaGFuZ2U6ICdtb3ZlJyxcbiAgICBlbmQ6ICdlbmQnXG4gIH0sXG4gIGdlc3R1cmU6IHtcbiAgICBzdGFydDogJ3N0YXJ0JyxcbiAgICBjaGFuZ2U6ICdjaGFuZ2UnLFxuICAgIGVuZDogJ2VuZCdcbiAgfVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIGlmICghc3RyaW5nKSByZXR1cm4gJyc7XG4gIHJldHVybiBzdHJpbmdbMF0udG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cbmNvbnN0IGFjdGlvbnNXaXRob3V0Q2FwdHVyZVN1cHBvcnRlZCA9IFsnZW50ZXInLCAnbGVhdmUnXTtcbmZ1bmN0aW9uIGhhc0NhcHR1cmUoY2FwdHVyZSA9IGZhbHNlLCBhY3Rpb25LZXkpIHtcbiAgcmV0dXJuIGNhcHR1cmUgJiYgIWFjdGlvbnNXaXRob3V0Q2FwdHVyZVN1cHBvcnRlZC5pbmNsdWRlcyhhY3Rpb25LZXkpO1xufVxuZnVuY3Rpb24gdG9IYW5kbGVyUHJvcChkZXZpY2UsIGFjdGlvbiA9ICcnLCBjYXB0dXJlID0gZmFsc2UpIHtcbiAgY29uc3QgZGV2aWNlUHJvcHMgPSBFVkVOVF9UWVBFX01BUFtkZXZpY2VdO1xuICBjb25zdCBhY3Rpb25LZXkgPSBkZXZpY2VQcm9wcyA/IGRldmljZVByb3BzW2FjdGlvbl0gfHwgYWN0aW9uIDogYWN0aW9uO1xuICByZXR1cm4gJ29uJyArIGNhcGl0YWxpemUoZGV2aWNlKSArIGNhcGl0YWxpemUoYWN0aW9uS2V5KSArIChoYXNDYXB0dXJlKGNhcHR1cmUsIGFjdGlvbktleSkgPyAnQ2FwdHVyZScgOiAnJyk7XG59XG5jb25zdCBwb2ludGVyQ2FwdHVyZUV2ZW50cyA9IFsnZ290cG9pbnRlcmNhcHR1cmUnLCAnbG9zdHBvaW50ZXJjYXB0dXJlJ107XG5mdW5jdGlvbiBwYXJzZVByb3AocHJvcCkge1xuICBsZXQgZXZlbnRLZXkgPSBwcm9wLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBwYXNzaXZlID0gISF+ZXZlbnRLZXkuaW5kZXhPZigncGFzc2l2ZScpO1xuICBpZiAocGFzc2l2ZSkgZXZlbnRLZXkgPSBldmVudEtleS5yZXBsYWNlKCdwYXNzaXZlJywgJycpO1xuICBjb25zdCBjYXB0dXJlS2V5ID0gcG9pbnRlckNhcHR1cmVFdmVudHMuaW5jbHVkZXMoZXZlbnRLZXkpID8gJ2NhcHR1cmVjYXB0dXJlJyA6ICdjYXB0dXJlJztcbiAgY29uc3QgY2FwdHVyZSA9ICEhfmV2ZW50S2V5LmluZGV4T2YoY2FwdHVyZUtleSk7XG4gIGlmIChjYXB0dXJlKSBldmVudEtleSA9IGV2ZW50S2V5LnJlcGxhY2UoJ2NhcHR1cmUnLCAnJyk7XG4gIHJldHVybiB7XG4gICAgZGV2aWNlOiBldmVudEtleSxcbiAgICBjYXB0dXJlLFxuICAgIHBhc3NpdmVcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvRG9tRXZlbnRUeXBlKGRldmljZSwgYWN0aW9uID0gJycpIHtcbiAgY29uc3QgZGV2aWNlUHJvcHMgPSBFVkVOVF9UWVBFX01BUFtkZXZpY2VdO1xuICBjb25zdCBhY3Rpb25LZXkgPSBkZXZpY2VQcm9wcyA/IGRldmljZVByb3BzW2FjdGlvbl0gfHwgYWN0aW9uIDogYWN0aW9uO1xuICByZXR1cm4gZGV2aWNlICsgYWN0aW9uS2V5O1xufVxuZnVuY3Rpb24gaXNUb3VjaChldmVudCkge1xuICByZXR1cm4gJ3RvdWNoZXMnIGluIGV2ZW50O1xufVxuZnVuY3Rpb24gZ2V0UG9pbnRlclR5cGUoZXZlbnQpIHtcbiAgaWYgKGlzVG91Y2goZXZlbnQpKSByZXR1cm4gJ3RvdWNoJztcbiAgaWYgKCdwb2ludGVyVHlwZScgaW4gZXZlbnQpIHJldHVybiBldmVudC5wb2ludGVyVHlwZTtcbiAgcmV0dXJuICdtb3VzZSc7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VGFyZ2V0VG91Y2hMaXN0KGV2ZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGV2ZW50LnRvdWNoZXMpLmZpbHRlcihlID0+IHtcbiAgICB2YXIgX2V2ZW50JGN1cnJlbnRUYXJnZXQsIF9ldmVudCRjdXJyZW50VGFyZ2V0JDtcbiAgICByZXR1cm4gZS50YXJnZXQgPT09IGV2ZW50LmN1cnJlbnRUYXJnZXQgfHwgKChfZXZlbnQkY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQpID09PSBudWxsIHx8IF9ldmVudCRjdXJyZW50VGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2V2ZW50JGN1cnJlbnRUYXJnZXQkID0gX2V2ZW50JGN1cnJlbnRUYXJnZXQuY29udGFpbnMpID09PSBudWxsIHx8IF9ldmVudCRjdXJyZW50VGFyZ2V0JCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2V2ZW50JGN1cnJlbnRUYXJnZXQkLmNhbGwoX2V2ZW50JGN1cnJlbnRUYXJnZXQsIGUudGFyZ2V0KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSAndG91Y2hlbmQnIHx8IGV2ZW50LnR5cGUgPT09ICd0b3VjaGNhbmNlbCcgPyBldmVudC5jaGFuZ2VkVG91Y2hlcyA6IGV2ZW50LnRhcmdldFRvdWNoZXM7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBpc1RvdWNoKGV2ZW50KSA/IGdldFRvdWNoTGlzdChldmVudClbMF0gOiBldmVudDtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlQW5nbGUoUDEsIFAyKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZHggPSBQMi5jbGllbnRYIC0gUDEuY2xpZW50WDtcbiAgICBjb25zdCBkeSA9IFAyLmNsaWVudFkgLSBQMS5jbGllbnRZO1xuICAgIGNvbnN0IGN4ID0gKFAyLmNsaWVudFggKyBQMS5jbGllbnRYKSAvIDI7XG4gICAgY29uc3QgY3kgPSAoUDIuY2xpZW50WSArIFAxLmNsaWVudFkpIC8gMjtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgICBjb25zdCBhbmdsZSA9IC0oTWF0aC5hdGFuMihkeCwgZHkpICogMTgwKSAvIE1hdGguUEk7XG4gICAgY29uc3Qgb3JpZ2luID0gW2N4LCBjeV07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuZ2xlLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBvcmlnaW5cbiAgICB9O1xuICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHRvdWNoSWRzKGV2ZW50KSB7XG4gIHJldHVybiBnZXRDdXJyZW50VGFyZ2V0VG91Y2hMaXN0KGV2ZW50KS5tYXAodG91Y2ggPT4gdG91Y2guaWRlbnRpZmllcik7XG59XG5mdW5jdGlvbiB0b3VjaERpc3RhbmNlQW5nbGUoZXZlbnQsIGlkcykge1xuICBjb25zdCBbUDEsIFAyXSA9IEFycmF5LmZyb20oZXZlbnQudG91Y2hlcykuZmlsdGVyKHRvdWNoID0+IGlkcy5pbmNsdWRlcyh0b3VjaC5pZGVudGlmaWVyKSk7XG4gIHJldHVybiBkaXN0YW5jZUFuZ2xlKFAxLCBQMik7XG59XG5mdW5jdGlvbiBwb2ludGVySWQoZXZlbnQpIHtcbiAgY29uc3QgdmFsdWVFdmVudCA9IGdldFZhbHVlRXZlbnQoZXZlbnQpO1xuICByZXR1cm4gaXNUb3VjaChldmVudCkgPyB2YWx1ZUV2ZW50LmlkZW50aWZpZXIgOiB2YWx1ZUV2ZW50LnBvaW50ZXJJZDtcbn1cbmZ1bmN0aW9uIHBvaW50ZXJWYWx1ZXMoZXZlbnQpIHtcbiAgY29uc3QgdmFsdWVFdmVudCA9IGdldFZhbHVlRXZlbnQoZXZlbnQpO1xuICByZXR1cm4gW3ZhbHVlRXZlbnQuY2xpZW50WCwgdmFsdWVFdmVudC5jbGllbnRZXTtcbn1cbmNvbnN0IExJTkVfSEVJR0hUID0gNDA7XG5jb25zdCBQQUdFX0hFSUdIVCA9IDgwMDtcbmZ1bmN0aW9uIHdoZWVsVmFsdWVzKGV2ZW50KSB7XG4gIGxldCB7XG4gICAgZGVsdGFYLFxuICAgIGRlbHRhWSxcbiAgICBkZWx0YU1vZGVcbiAgfSA9IGV2ZW50O1xuICBpZiAoZGVsdGFNb2RlID09PSAxKSB7XG4gICAgZGVsdGFYICo9IExJTkVfSEVJR0hUO1xuICAgIGRlbHRhWSAqPSBMSU5FX0hFSUdIVDtcbiAgfSBlbHNlIGlmIChkZWx0YU1vZGUgPT09IDIpIHtcbiAgICBkZWx0YVggKj0gUEFHRV9IRUlHSFQ7XG4gICAgZGVsdGFZICo9IFBBR0VfSEVJR0hUO1xuICB9XG4gIHJldHVybiBbZGVsdGFYLCBkZWx0YVldO1xufVxuZnVuY3Rpb24gc2Nyb2xsVmFsdWVzKGV2ZW50KSB7XG4gIHZhciBfcmVmLCBfcmVmMjtcbiAgY29uc3Qge1xuICAgIHNjcm9sbFgsXG4gICAgc2Nyb2xsWSxcbiAgICBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcFxuICB9ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgcmV0dXJuIFsoX3JlZiA9IHNjcm9sbFggIT09IG51bGwgJiYgc2Nyb2xsWCAhPT0gdm9pZCAwID8gc2Nyb2xsWCA6IHNjcm9sbExlZnQpICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiAwLCAoX3JlZjIgPSBzY3JvbGxZICE9PSBudWxsICYmIHNjcm9sbFkgIT09IHZvaWQgMCA/IHNjcm9sbFkgOiBzY3JvbGxUb3ApICE9PSBudWxsICYmIF9yZWYyICE9PSB2b2lkIDAgPyBfcmVmMiA6IDBdO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnREZXRhaWxzKGV2ZW50KSB7XG4gIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgaWYgKCdidXR0b25zJyBpbiBldmVudCkgcGF5bG9hZC5idXR0b25zID0gZXZlbnQuYnV0dG9ucztcbiAgaWYgKCdzaGlmdEtleScgaW4gZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaGlmdEtleSxcbiAgICAgIGFsdEtleSxcbiAgICAgIG1ldGFLZXksXG4gICAgICBjdHJsS2V5XG4gICAgfSA9IGV2ZW50O1xuICAgIE9iamVjdC5hc3NpZ24ocGF5bG9hZCwge1xuICAgICAgc2hpZnRLZXksXG4gICAgICBhbHRLZXksXG4gICAgICBtZXRhS2V5LFxuICAgICAgY3RybEtleVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXlsb2FkO1xufVxuXG5mdW5jdGlvbiBjYWxsKHYsIC4uLmFyZ3MpIHtcbiAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHYoLi4uYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZnVuY3Rpb24gY2hhaW4oLi4uZm5zKSB7XG4gIGlmIChmbnMubGVuZ3RoID09PSAwKSByZXR1cm4gbm9vcDtcbiAgaWYgKGZucy5sZW5ndGggPT09IDEpIHJldHVybiBmbnNbMF07XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuICAgICAgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KHZhbHVlLCBmYWxsYmFjaykge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZmFsbGJhY2ssIHZhbHVlIHx8IHt9KTtcbn1cblxuY29uc3QgQkVGT1JFX0xBU1RfS0lORU1BVElDU19ERUxBWSA9IDMyO1xuY2xhc3MgRW5naW5lIHtcbiAgY29uc3RydWN0b3IoY3RybCwgYXJncywga2V5KSB7XG4gICAgdGhpcy5jdHJsID0gY3RybDtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIGlmICghdGhpcy5zdGF0ZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgdGhpcy5jb21wdXRlVmFsdWVzKFswLCAwXSk7XG4gICAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgICBpZiAodGhpcy5pbml0KSB0aGlzLmluaXQoKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuc3RhdGVbdGhpcy5rZXldO1xuICB9XG4gIHNldCBzdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuY3RybC5zdGF0ZVt0aGlzLmtleV0gPSBzdGF0ZTtcbiAgfVxuICBnZXQgc2hhcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuc3RhdGUuc2hhcmVkO1xuICB9XG4gIGdldCBldmVudFN0b3JlKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuZ2VzdHVyZUV2ZW50U3RvcmVzW3RoaXMua2V5XTtcbiAgfVxuICBnZXQgdGltZW91dFN0b3JlKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuZ2VzdHVyZVRpbWVvdXRTdG9yZXNbdGhpcy5rZXldO1xuICB9XG4gIGdldCBjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5jb25maWdbdGhpcy5rZXldO1xuICB9XG4gIGdldCBzaGFyZWRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3RybC5jb25maWcuc2hhcmVkO1xuICB9XG4gIGdldCBoYW5kbGVyKCkge1xuICAgIHJldHVybiB0aGlzLmN0cmwuaGFuZGxlcnNbdGhpcy5rZXldO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlLFxuICAgICAgc2hhcmVkLFxuICAgICAgaW5nS2V5LFxuICAgICAgYXJnc1xuICAgIH0gPSB0aGlzO1xuICAgIHNoYXJlZFtpbmdLZXldID0gc3RhdGUuX2FjdGl2ZSA9IHN0YXRlLmFjdGl2ZSA9IHN0YXRlLl9ibG9ja2VkID0gc3RhdGUuX2ZvcmNlID0gZmFsc2U7XG4gICAgc3RhdGUuX3N0ZXAgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICBzdGF0ZS5pbnRlbnRpb25hbCA9IGZhbHNlO1xuICAgIHN0YXRlLl9tb3ZlbWVudCA9IFswLCAwXTtcbiAgICBzdGF0ZS5fZGlzdGFuY2UgPSBbMCwgMF07XG4gICAgc3RhdGUuX2RpcmVjdGlvbiA9IFswLCAwXTtcbiAgICBzdGF0ZS5fZGVsdGEgPSBbMCwgMF07XG4gICAgc3RhdGUuX2JvdW5kcyA9IFtbLUluZmluaXR5LCBJbmZpbml0eV0sIFstSW5maW5pdHksIEluZmluaXR5XV07XG4gICAgc3RhdGUuYXJncyA9IGFyZ3M7XG4gICAgc3RhdGUuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5tZW1vID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLmVsYXBzZWRUaW1lID0gc3RhdGUudGltZURlbHRhID0gMDtcbiAgICBzdGF0ZS5kaXJlY3Rpb24gPSBbMCwgMF07XG4gICAgc3RhdGUuZGlzdGFuY2UgPSBbMCwgMF07XG4gICAgc3RhdGUub3ZlcmZsb3cgPSBbMCwgMF07XG4gICAgc3RhdGUuX21vdmVtZW50Qm91bmQgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICBzdGF0ZS52ZWxvY2l0eSA9IFswLCAwXTtcbiAgICBzdGF0ZS5tb3ZlbWVudCA9IFswLCAwXTtcbiAgICBzdGF0ZS5kZWx0YSA9IFswLCAwXTtcbiAgICBzdGF0ZS50aW1lU3RhbXAgPSAwO1xuICB9XG4gIHN0YXJ0KGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGlmICghc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5jb21wdXRlSW5pdGlhbCgpO1xuICAgICAgc3RhdGUuX2FjdGl2ZSA9IHRydWU7XG4gICAgICBzdGF0ZS50YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBzdGF0ZS5jdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgIHN0YXRlLmxhc3RPZmZzZXQgPSBjb25maWcuZnJvbSA/IGNhbGwoY29uZmlnLmZyb20sIHN0YXRlKSA6IHN0YXRlLm9mZnNldDtcbiAgICAgIHN0YXRlLm9mZnNldCA9IHN0YXRlLmxhc3RPZmZzZXQ7XG4gICAgICBzdGF0ZS5zdGFydFRpbWUgPSBzdGF0ZS50aW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgfVxuICB9XG4gIGNvbXB1dGVWYWx1ZXModmFsdWVzKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl92YWx1ZXMgPSB2YWx1ZXM7XG4gICAgc3RhdGUudmFsdWVzID0gdGhpcy5jb25maWcudHJhbnNmb3JtKHZhbHVlcyk7XG4gIH1cbiAgY29tcHV0ZUluaXRpYWwoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9pbml0aWFsID0gc3RhdGUuX3ZhbHVlcztcbiAgICBzdGF0ZS5pbml0aWFsID0gc3RhdGUudmFsdWVzO1xuICB9XG4gIGNvbXB1dGUoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHNoYXJlZFxuICAgIH0gPSB0aGlzO1xuICAgIHN0YXRlLmFyZ3MgPSB0aGlzLmFyZ3M7XG4gICAgbGV0IGR0ID0gMDtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIHN0YXRlLmV2ZW50ID0gZXZlbnQ7XG4gICAgICBpZiAoY29uZmlnLnByZXZlbnREZWZhdWx0ICYmIGV2ZW50LmNhbmNlbGFibGUpIHN0YXRlLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdGF0ZS50eXBlID0gZXZlbnQudHlwZTtcbiAgICAgIHNoYXJlZC50b3VjaGVzID0gdGhpcy5jdHJsLnBvaW50ZXJJZHMuc2l6ZSB8fCB0aGlzLmN0cmwudG91Y2hJZHMuc2l6ZTtcbiAgICAgIHNoYXJlZC5sb2NrZWQgPSAhIWRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudDtcbiAgICAgIE9iamVjdC5hc3NpZ24oc2hhcmVkLCBnZXRFdmVudERldGFpbHMoZXZlbnQpKTtcbiAgICAgIHNoYXJlZC5kb3duID0gc2hhcmVkLnByZXNzZWQgPSBzaGFyZWQuYnV0dG9ucyAlIDIgPT09IDEgfHwgc2hhcmVkLnRvdWNoZXMgPiAwO1xuICAgICAgZHQgPSBldmVudC50aW1lU3RhbXAgLSBzdGF0ZS50aW1lU3RhbXA7XG4gICAgICBzdGF0ZS50aW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICBzdGF0ZS5lbGFwc2VkVGltZSA9IHN0YXRlLnRpbWVTdGFtcCAtIHN0YXRlLnN0YXJ0VGltZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IF9hYnNvbHV0ZURlbHRhID0gc3RhdGUuX2RlbHRhLm1hcChNYXRoLmFicyk7XG4gICAgICBWLmFkZFRvKHN0YXRlLl9kaXN0YW5jZSwgX2Fic29sdXRlRGVsdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5heGlzSW50ZW50KSB0aGlzLmF4aXNJbnRlbnQoZXZlbnQpO1xuICAgIGNvbnN0IFtfbTAsIF9tMV0gPSBzdGF0ZS5fbW92ZW1lbnQ7XG4gICAgY29uc3QgW3QwLCB0MV0gPSBjb25maWcudGhyZXNob2xkO1xuICAgIGNvbnN0IHtcbiAgICAgIF9zdGVwLFxuICAgICAgdmFsdWVzXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmIChjb25maWcuaGFzQ3VzdG9tVHJhbnNmb3JtKSB7XG4gICAgICBpZiAoX3N0ZXBbMF0gPT09IGZhbHNlKSBfc3RlcFswXSA9IE1hdGguYWJzKF9tMCkgPj0gdDAgJiYgdmFsdWVzWzBdO1xuICAgICAgaWYgKF9zdGVwWzFdID09PSBmYWxzZSkgX3N0ZXBbMV0gPSBNYXRoLmFicyhfbTEpID49IHQxICYmIHZhbHVlc1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9zdGVwWzBdID09PSBmYWxzZSkgX3N0ZXBbMF0gPSBNYXRoLmFicyhfbTApID49IHQwICYmIE1hdGguc2lnbihfbTApICogdDA7XG4gICAgICBpZiAoX3N0ZXBbMV0gPT09IGZhbHNlKSBfc3RlcFsxXSA9IE1hdGguYWJzKF9tMSkgPj0gdDEgJiYgTWF0aC5zaWduKF9tMSkgKiB0MTtcbiAgICB9XG4gICAgc3RhdGUuaW50ZW50aW9uYWwgPSBfc3RlcFswXSAhPT0gZmFsc2UgfHwgX3N0ZXBbMV0gIT09IGZhbHNlO1xuICAgIGlmICghc3RhdGUuaW50ZW50aW9uYWwpIHJldHVybjtcbiAgICBjb25zdCBtb3ZlbWVudCA9IFswLCAwXTtcbiAgICBpZiAoY29uZmlnLmhhc0N1c3RvbVRyYW5zZm9ybSkge1xuICAgICAgY29uc3QgW3YwLCB2MV0gPSB2YWx1ZXM7XG4gICAgICBtb3ZlbWVudFswXSA9IF9zdGVwWzBdICE9PSBmYWxzZSA/IHYwIC0gX3N0ZXBbMF0gOiAwO1xuICAgICAgbW92ZW1lbnRbMV0gPSBfc3RlcFsxXSAhPT0gZmFsc2UgPyB2MSAtIF9zdGVwWzFdIDogMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbW92ZW1lbnRbMF0gPSBfc3RlcFswXSAhPT0gZmFsc2UgPyBfbTAgLSBfc3RlcFswXSA6IDA7XG4gICAgICBtb3ZlbWVudFsxXSA9IF9zdGVwWzFdICE9PSBmYWxzZSA/IF9tMSAtIF9zdGVwWzFdIDogMDtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVzdHJpY3RUb0F4aXMgJiYgIXN0YXRlLl9ibG9ja2VkKSB0aGlzLnJlc3RyaWN0VG9BeGlzKG1vdmVtZW50KTtcbiAgICBjb25zdCBwcmV2aW91c09mZnNldCA9IHN0YXRlLm9mZnNldDtcbiAgICBjb25zdCBnZXN0dXJlSXNBY3RpdmUgPSBzdGF0ZS5fYWN0aXZlICYmICFzdGF0ZS5fYmxvY2tlZCB8fCBzdGF0ZS5hY3RpdmU7XG4gICAgaWYgKGdlc3R1cmVJc0FjdGl2ZSkge1xuICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5fYWN0aXZlICYmICFzdGF0ZS5hY3RpdmU7XG4gICAgICBzdGF0ZS5sYXN0ID0gIXN0YXRlLl9hY3RpdmUgJiYgc3RhdGUuYWN0aXZlO1xuICAgICAgc3RhdGUuYWN0aXZlID0gc2hhcmVkW3RoaXMuaW5nS2V5XSA9IHN0YXRlLl9hY3RpdmU7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmZpcnN0KSB7XG4gICAgICAgICAgaWYgKCdib3VuZHMnIGluIGNvbmZpZykgc3RhdGUuX2JvdW5kcyA9IGNhbGwoY29uZmlnLmJvdW5kcywgc3RhdGUpO1xuICAgICAgICAgIGlmICh0aGlzLnNldHVwKSB0aGlzLnNldHVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW92ZW1lbnQgPSBtb3ZlbWVudDtcbiAgICAgICAgdGhpcy5jb21wdXRlT2Zmc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IFtveCwgb3ldID0gc3RhdGUub2Zmc2V0O1xuICAgIGNvbnN0IFtbeDAsIHgxXSwgW3kwLCB5MV1dID0gc3RhdGUuX2JvdW5kcztcbiAgICBzdGF0ZS5vdmVyZmxvdyA9IFtveCA8IHgwID8gLTEgOiBveCA+IHgxID8gMSA6IDAsIG95IDwgeTAgPyAtMSA6IG95ID4geTEgPyAxIDogMF07XG4gICAgc3RhdGUuX21vdmVtZW50Qm91bmRbMF0gPSBzdGF0ZS5vdmVyZmxvd1swXSA/IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzBdID09PSBmYWxzZSA/IHN0YXRlLl9tb3ZlbWVudFswXSA6IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzBdIDogZmFsc2U7XG4gICAgc3RhdGUuX21vdmVtZW50Qm91bmRbMV0gPSBzdGF0ZS5vdmVyZmxvd1sxXSA/IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzFdID09PSBmYWxzZSA/IHN0YXRlLl9tb3ZlbWVudFsxXSA6IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzFdIDogZmFsc2U7XG4gICAgY29uc3QgcnViYmVyYmFuZCA9IHN0YXRlLl9hY3RpdmUgPyBjb25maWcucnViYmVyYmFuZCB8fCBbMCwgMF0gOiBbMCwgMF07XG4gICAgc3RhdGUub2Zmc2V0ID0gY29tcHV0ZVJ1YmJlcmJhbmQoc3RhdGUuX2JvdW5kcywgc3RhdGUub2Zmc2V0LCBydWJiZXJiYW5kKTtcbiAgICBzdGF0ZS5kZWx0YSA9IFYuc3ViKHN0YXRlLm9mZnNldCwgcHJldmlvdXNPZmZzZXQpO1xuICAgIHRoaXMuY29tcHV0ZU1vdmVtZW50KCk7XG4gICAgaWYgKGdlc3R1cmVJc0FjdGl2ZSAmJiAoIXN0YXRlLmxhc3QgfHwgZHQgPiBCRUZPUkVfTEFTVF9LSU5FTUFUSUNTX0RFTEFZKSkge1xuICAgICAgc3RhdGUuZGVsdGEgPSBWLnN1YihzdGF0ZS5vZmZzZXQsIHByZXZpb3VzT2Zmc2V0KTtcbiAgICAgIGNvbnN0IGFic29sdXRlRGVsdGEgPSBzdGF0ZS5kZWx0YS5tYXAoTWF0aC5hYnMpO1xuICAgICAgVi5hZGRUbyhzdGF0ZS5kaXN0YW5jZSwgYWJzb2x1dGVEZWx0YSk7XG4gICAgICBzdGF0ZS5kaXJlY3Rpb24gPSBzdGF0ZS5kZWx0YS5tYXAoTWF0aC5zaWduKTtcbiAgICAgIHN0YXRlLl9kaXJlY3Rpb24gPSBzdGF0ZS5fZGVsdGEubWFwKE1hdGguc2lnbik7XG4gICAgICBpZiAoIXN0YXRlLmZpcnN0ICYmIGR0ID4gMCkge1xuICAgICAgICBzdGF0ZS52ZWxvY2l0eSA9IFthYnNvbHV0ZURlbHRhWzBdIC8gZHQsIGFic29sdXRlRGVsdGFbMV0gLyBkdF07XG4gICAgICAgIHN0YXRlLnRpbWVEZWx0YSA9IGR0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbWl0KCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBzaGFyZWQgPSB0aGlzLnNoYXJlZDtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIXN0YXRlLl9hY3RpdmUpIHRoaXMuY2xlYW4oKTtcbiAgICBpZiAoKHN0YXRlLl9ibG9ja2VkIHx8ICFzdGF0ZS5pbnRlbnRpb25hbCkgJiYgIXN0YXRlLl9mb3JjZSAmJiAhY29uZmlnLnRyaWdnZXJBbGxFdmVudHMpIHJldHVybjtcbiAgICBjb25zdCBtZW1vID0gdGhpcy5oYW5kbGVyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzaGFyZWQpLCBzdGF0ZSksIHt9LCB7XG4gICAgICBbdGhpcy5hbGlhc0tleV06IHN0YXRlLnZhbHVlc1xuICAgIH0pKTtcbiAgICBpZiAobWVtbyAhPT0gdW5kZWZpbmVkKSBzdGF0ZS5tZW1vID0gbWVtbztcbiAgfVxuICBjbGVhbigpIHtcbiAgICB0aGlzLmV2ZW50U3RvcmUuY2xlYW4oKTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5jbGVhbigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEF4aXMoW2R4LCBkeV0sIHRocmVzaG9sZCkge1xuICBjb25zdCBhYnNEeCA9IE1hdGguYWJzKGR4KTtcbiAgY29uc3QgYWJzRHkgPSBNYXRoLmFicyhkeSk7XG4gIGlmIChhYnNEeCA+IGFic0R5ICYmIGFic0R4ID4gdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAoYWJzRHkgPiBhYnNEeCAmJiBhYnNEeSA+IHRocmVzaG9sZCkge1xuICAgIHJldHVybiAneSc7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIENvb3JkaW5hdGVzRW5naW5lIGV4dGVuZHMgRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsaWFzS2V5XCIsICd4eScpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgdGhpcy5zdGF0ZS5heGlzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBbMCwgMF07XG4gICAgdGhpcy5zdGF0ZS5sYXN0T2Zmc2V0ID0gWzAsIDBdO1xuICB9XG4gIGNvbXB1dGVPZmZzZXQoKSB7XG4gICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBWLmFkZCh0aGlzLnN0YXRlLmxhc3RPZmZzZXQsIHRoaXMuc3RhdGUubW92ZW1lbnQpO1xuICB9XG4gIGNvbXB1dGVNb3ZlbWVudCgpIHtcbiAgICB0aGlzLnN0YXRlLm1vdmVtZW50ID0gVi5zdWIodGhpcy5zdGF0ZS5vZmZzZXQsIHRoaXMuc3RhdGUubGFzdE9mZnNldCk7XG4gIH1cbiAgYXhpc0ludGVudChldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBpZiAoIXN0YXRlLmF4aXMgJiYgZXZlbnQpIHtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHR5cGVvZiBjb25maWcuYXhpc1RocmVzaG9sZCA9PT0gJ29iamVjdCcgPyBjb25maWcuYXhpc1RocmVzaG9sZFtnZXRQb2ludGVyVHlwZShldmVudCldIDogY29uZmlnLmF4aXNUaHJlc2hvbGQ7XG4gICAgICBzdGF0ZS5heGlzID0gc2VsZWN0QXhpcyhzdGF0ZS5fbW92ZW1lbnQsIHRocmVzaG9sZCk7XG4gICAgfVxuICAgIHN0YXRlLl9ibG9ja2VkID0gKGNvbmZpZy5sb2NrRGlyZWN0aW9uIHx8ICEhY29uZmlnLmF4aXMpICYmICFzdGF0ZS5heGlzIHx8ICEhY29uZmlnLmF4aXMgJiYgY29uZmlnLmF4aXMgIT09IHN0YXRlLmF4aXM7XG4gIH1cbiAgcmVzdHJpY3RUb0F4aXModikge1xuICAgIGlmICh0aGlzLmNvbmZpZy5heGlzIHx8IHRoaXMuY29uZmlnLmxvY2tEaXJlY3Rpb24pIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS5heGlzKSB7XG4gICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgIHZbMV0gPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICB2WzBdID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaWRlbnRpdHkgPSB2ID0+IHY7XG5jb25zdCBERUZBVUxUX1JVQkJFUkJBTkQgPSAwLjE1O1xuY29uc3QgY29tbW9uQ29uZmlnUmVzb2x2ZXIgPSB7XG4gIGVuYWJsZWQodmFsdWUgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBldmVudE9wdGlvbnModmFsdWUsIF9rLCBjb25maWcpIHtcbiAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvbmZpZy5zaGFyZWQuZXZlbnRPcHRpb25zKSwgdmFsdWUpO1xuICB9LFxuICBwcmV2ZW50RGVmYXVsdCh2YWx1ZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICB0cmlnZ2VyQWxsRXZlbnRzKHZhbHVlID0gZmFsc2UpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHJ1YmJlcmJhbmQodmFsdWUgPSAwKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICByZXR1cm4gW0RFRkFVTFRfUlVCQkVSQkFORCwgREVGQVVMVF9SVUJCRVJCQU5EXTtcbiAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gVi50b1ZlY3Rvcih2YWx1ZSk7XG4gICAgfVxuICB9LFxuICBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSByZXR1cm4gVi50b1ZlY3Rvcih2YWx1ZSk7XG4gIH0sXG4gIHRyYW5zZm9ybSh2YWx1ZSwgX2ssIGNvbmZpZykge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHZhbHVlIHx8IGNvbmZpZy5zaGFyZWQudHJhbnNmb3JtO1xuICAgIHRoaXMuaGFzQ3VzdG9tVHJhbnNmb3JtID0gISF0cmFuc2Zvcm07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zdCBvcmlnaW5hbFRyYW5zZm9ybSA9IHRyYW5zZm9ybSB8fCBpZGVudGl0eTtcbiAgICAgIHJldHVybiB2ID0+IHtcbiAgICAgICAgY29uc3QgciA9IG9yaWdpbmFsVHJhbnNmb3JtKHYpO1xuICAgICAgICBpZiAoIWlzRmluaXRlKHJbMF0pIHx8ICFpc0Zpbml0ZShyWzFdKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IGNvbmZpZy50cmFuc2Zvcm0oKSBtdXN0IHByb2R1Y2UgYSB2YWxpZCByZXN1bHQsIGJ1dCBpdCB3YXM6IFske3JbMF19LCR7WzFdfV1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm0gfHwgaWRlbnRpdHk7XG4gIH0sXG4gIHRocmVzaG9sZCh2YWx1ZSkge1xuICAgIHJldHVybiBWLnRvVmVjdG9yKHZhbHVlLCAwKTtcbiAgfVxufTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBPYmplY3QuYXNzaWduKGNvbW1vbkNvbmZpZ1Jlc29sdmVyLCB7XG4gICAgZG9tVGFyZ2V0KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYGRvbVRhcmdldFxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGB0YXJnZXRcXGAuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH0sXG4gICAgbG9ja0RpcmVjdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBsb2NrRGlyZWN0aW9uXFxgIG9wdGlvbiBoYXMgYmVlbiBtZXJnZWQgd2l0aCBcXGBheGlzXFxgLiBVc2UgaXQgYXMgaW4gXFxgeyBheGlzOiAnbG9jaycgfVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIGluaXRpYWwodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgaW5pdGlhbFxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBmcm9tXFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBERUZBVUxUX0FYSVNfVEhSRVNIT0xEID0gMDtcbmNvbnN0IGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29tbW9uQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBheGlzKF92LCBfaywge1xuICAgIGF4aXNcbiAgfSkge1xuICAgIHRoaXMubG9ja0RpcmVjdGlvbiA9IGF4aXMgPT09ICdsb2NrJztcbiAgICBpZiAoIXRoaXMubG9ja0RpcmVjdGlvbikgcmV0dXJuIGF4aXM7XG4gIH0sXG4gIGF4aXNUaHJlc2hvbGQodmFsdWUgPSBERUZBVUxUX0FYSVNfVEhSRVNIT0xEKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBib3VuZHModmFsdWUgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBzdGF0ZSA9PiBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyLmJvdW5kcyh2YWx1ZShzdGF0ZSkpO1xuICAgIH1cbiAgICBpZiAoJ2N1cnJlbnQnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gKCkgPT4gdmFsdWUuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQgPSAtSW5maW5pdHksXG4gICAgICByaWdodCA9IEluZmluaXR5LFxuICAgICAgdG9wID0gLUluZmluaXR5LFxuICAgICAgYm90dG9tID0gSW5maW5pdHlcbiAgICB9ID0gdmFsdWU7XG4gICAgcmV0dXJuIFtbbGVmdCwgcmlnaHRdLCBbdG9wLCBib3R0b21dXTtcbiAgfVxufSk7XG5cbmNvbnN0IEtFWVNfREVMVEFfTUFQID0ge1xuICBBcnJvd1JpZ2h0OiAoZGlzcGxhY2VtZW50LCBmYWN0b3IgPSAxKSA9PiBbZGlzcGxhY2VtZW50ICogZmFjdG9yLCAwXSxcbiAgQXJyb3dMZWZ0OiAoZGlzcGxhY2VtZW50LCBmYWN0b3IgPSAxKSA9PiBbLTEgKiBkaXNwbGFjZW1lbnQgKiBmYWN0b3IsIDBdLFxuICBBcnJvd1VwOiAoZGlzcGxhY2VtZW50LCBmYWN0b3IgPSAxKSA9PiBbMCwgLTEgKiBkaXNwbGFjZW1lbnQgKiBmYWN0b3JdLFxuICBBcnJvd0Rvd246IChkaXNwbGFjZW1lbnQsIGZhY3RvciA9IDEpID0+IFswLCBkaXNwbGFjZW1lbnQgKiBmYWN0b3JdXG59O1xuY2xhc3MgRHJhZ0VuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnZHJhZ2dpbmcnKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBzdXBlci5yZXNldCgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fcG9pbnRlcklkID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLl9wb2ludGVyQWN0aXZlID0gZmFsc2U7XG4gICAgc3RhdGUuX2tleWJvYXJkQWN0aXZlID0gZmFsc2U7XG4gICAgc3RhdGUuX3ByZXZlbnRTY3JvbGwgPSBmYWxzZTtcbiAgICBzdGF0ZS5fZGVsYXllZCA9IGZhbHNlO1xuICAgIHN0YXRlLnN3aXBlID0gWzAsIDBdO1xuICAgIHN0YXRlLnRhcCA9IGZhbHNlO1xuICAgIHN0YXRlLmNhbmNlbGVkID0gZmFsc2U7XG4gICAgc3RhdGUuY2FuY2VsID0gdGhpcy5jYW5jZWwuYmluZCh0aGlzKTtcbiAgfVxuICBzZXR1cCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLl9ib3VuZHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgY29uc3QgYm91bmRSZWN0ID0gc3RhdGUuX2JvdW5kcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSBzdGF0ZS5jdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgX2JvdW5kcyA9IHtcbiAgICAgICAgbGVmdDogYm91bmRSZWN0LmxlZnQgLSB0YXJnZXRSZWN0LmxlZnQgKyBzdGF0ZS5vZmZzZXRbMF0sXG4gICAgICAgIHJpZ2h0OiBib3VuZFJlY3QucmlnaHQgLSB0YXJnZXRSZWN0LnJpZ2h0ICsgc3RhdGUub2Zmc2V0WzBdLFxuICAgICAgICB0b3A6IGJvdW5kUmVjdC50b3AgLSB0YXJnZXRSZWN0LnRvcCArIHN0YXRlLm9mZnNldFsxXSxcbiAgICAgICAgYm90dG9tOiBib3VuZFJlY3QuYm90dG9tIC0gdGFyZ2V0UmVjdC5ib3R0b20gKyBzdGF0ZS5vZmZzZXRbMV1cbiAgICAgIH07XG4gICAgICBzdGF0ZS5fYm91bmRzID0gY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlci5ib3VuZHMoX2JvdW5kcyk7XG4gICAgfVxuICB9XG4gIGNhbmNlbCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmNhbmNlbGVkKSByZXR1cm47XG4gICAgc3RhdGUuY2FuY2VsZWQgPSB0cnVlO1xuICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgc2V0QWN0aXZlKCkge1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IHRoaXMuc3RhdGUuX3BvaW50ZXJBY3RpdmUgfHwgdGhpcy5zdGF0ZS5fa2V5Ym9hcmRBY3RpdmU7XG4gIH1cbiAgY2xlYW4oKSB7XG4gICAgdGhpcy5wb2ludGVyQ2xlYW4oKTtcbiAgICB0aGlzLnN0YXRlLl9wb2ludGVyQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZS5fa2V5Ym9hcmRBY3RpdmUgPSBmYWxzZTtcbiAgICBzdXBlci5jbGVhbigpO1xuICB9XG4gIHBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChldmVudC5idXR0b25zICE9IG51bGwgJiYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnBvaW50ZXJCdXR0b25zKSA/ICFjb25maWcucG9pbnRlckJ1dHRvbnMuaW5jbHVkZXMoZXZlbnQuYnV0dG9ucykgOiBjb25maWcucG9pbnRlckJ1dHRvbnMgIT09IC0xICYmIGNvbmZpZy5wb2ludGVyQnV0dG9ucyAhPT0gZXZlbnQuYnV0dG9ucykpIHJldHVybjtcbiAgICBjb25zdCBjdHJsSWRzID0gdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICBpZiAoY29uZmlnLnBvaW50ZXJDYXB0dXJlKSB7XG4gICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICB9XG4gICAgaWYgKGN0cmxJZHMgJiYgY3RybElkcy5zaXplID4gMSAmJiBzdGF0ZS5fcG9pbnRlckFjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMuc2V0dXBQb2ludGVyKGV2ZW50KTtcbiAgICBzdGF0ZS5fcG9pbnRlcklkID0gcG9pbnRlcklkKGV2ZW50KTtcbiAgICBzdGF0ZS5fcG9pbnRlckFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHBvaW50ZXJWYWx1ZXMoZXZlbnQpKTtcbiAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgaWYgKGNvbmZpZy5wcmV2ZW50U2Nyb2xsQXhpcyAmJiBnZXRQb2ludGVyVHlwZShldmVudCkgIT09ICdtb3VzZScpIHtcbiAgICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0dXBTY3JvbGxQcmV2ZW50aW9uKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5kZWxheSA+IDApIHtcbiAgICAgIHRoaXMuc2V0dXBEZWxheVRyaWdnZXIoZXZlbnQpO1xuICAgICAgaWYgKGNvbmZpZy50cmlnZ2VyQWxsRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgICAgIHRoaXMuZW1pdCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBzdGFydFBvaW50ZXJEcmFnKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9hY3RpdmUgPSB0cnVlO1xuICAgIHN0YXRlLl9wcmV2ZW50U2Nyb2xsID0gdHJ1ZTtcbiAgICBzdGF0ZS5fZGVsYXllZCA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgcG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFzdGF0ZS5fcG9pbnRlckFjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGlkID0gcG9pbnRlcklkKGV2ZW50KTtcbiAgICBpZiAoc3RhdGUuX3BvaW50ZXJJZCAhPT0gdW5kZWZpbmVkICYmIGlkICE9PSBzdGF0ZS5fcG9pbnRlcklkKSByZXR1cm47XG4gICAgY29uc3QgX3ZhbHVlcyA9IHBvaW50ZXJWYWx1ZXMoZXZlbnQpO1xuICAgIGlmIChkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQgPT09IGV2ZW50LnRhcmdldCkge1xuICAgICAgc3RhdGUuX2RlbHRhID0gW2V2ZW50Lm1vdmVtZW50WCwgZXZlbnQubW92ZW1lbnRZXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuX2RlbHRhID0gVi5zdWIoX3ZhbHVlcywgc3RhdGUuX3ZhbHVlcyk7XG4gICAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoX3ZhbHVlcyk7XG4gICAgfVxuICAgIFYuYWRkVG8oc3RhdGUuX21vdmVtZW50LCBzdGF0ZS5fZGVsdGEpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgaWYgKHN0YXRlLl9kZWxheWVkICYmIHN0YXRlLmludGVudGlvbmFsKSB7XG4gICAgICB0aGlzLnRpbWVvdXRTdG9yZS5yZW1vdmUoJ2RyYWdEZWxheScpO1xuICAgICAgc3RhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnByZXZlbnRTY3JvbGxBeGlzICYmICFzdGF0ZS5fcHJldmVudFNjcm9sbCkge1xuICAgICAgaWYgKHN0YXRlLmF4aXMpIHtcbiAgICAgICAgaWYgKHN0YXRlLmF4aXMgPT09IGNvbmZpZy5wcmV2ZW50U2Nyb2xsQXhpcyB8fCBjb25maWcucHJldmVudFNjcm9sbEF4aXMgPT09ICd4eScpIHtcbiAgICAgICAgICBzdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jbGVhbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXRTdG9yZS5yZW1vdmUoJ3N0YXJ0UG9pbnRlckRyYWcnKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9pbnRlckRyYWcoZXZlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBwb2ludGVyVXAoZXZlbnQpIHtcbiAgICB0aGlzLmN0cmwuc2V0RXZlbnRJZHMoZXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5jb25maWcucG9pbnRlckNhcHR1cmUgJiYgZXZlbnQudGFyZ2V0Lmhhc1BvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgO1xuICAgICAgICBldmVudC50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW0B1c2UtZ2VzdHVyZV06IElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBpdCdzIGxpa2VseSB0aGF0IHlvdSdyZSB1c2luZyBhbiBvdXRkYXRlZCB2ZXJzaW9uIG9mIFxcYEByZWFjdC10aHJlZS9maWJlclxcYC4gXFxuXFxuUGxlYXNlIHVwZ3JhZGUgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFzdGF0ZS5fYWN0aXZlIHx8ICFzdGF0ZS5fcG9pbnRlckFjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IGlkID0gcG9pbnRlcklkKGV2ZW50KTtcbiAgICBpZiAoc3RhdGUuX3BvaW50ZXJJZCAhPT0gdW5kZWZpbmVkICYmIGlkICE9PSBzdGF0ZS5fcG9pbnRlcklkKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fcG9pbnRlckFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0QWN0aXZlKCk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICBjb25zdCBbZHgsIGR5XSA9IHN0YXRlLl9kaXN0YW5jZTtcbiAgICBzdGF0ZS50YXAgPSBkeCA8PSBjb25maWcudGFwc1RocmVzaG9sZCAmJiBkeSA8PSBjb25maWcudGFwc1RocmVzaG9sZDtcbiAgICBpZiAoc3RhdGUudGFwICYmIGNvbmZpZy5maWx0ZXJUYXBzKSB7XG4gICAgICBzdGF0ZS5fZm9yY2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbX2R4LCBfZHldID0gc3RhdGUuX2RlbHRhO1xuICAgICAgY29uc3QgW19teCwgX215XSA9IHN0YXRlLl9tb3ZlbWVudDtcbiAgICAgIGNvbnN0IFtzdngsIHN2eV0gPSBjb25maWcuc3dpcGUudmVsb2NpdHk7XG4gICAgICBjb25zdCBbc3gsIHN5XSA9IGNvbmZpZy5zd2lwZS5kaXN0YW5jZTtcbiAgICAgIGNvbnN0IHNkdCA9IGNvbmZpZy5zd2lwZS5kdXJhdGlvbjtcbiAgICAgIGlmIChzdGF0ZS5lbGFwc2VkVGltZSA8IHNkdCkge1xuICAgICAgICBjb25zdCBfdnggPSBNYXRoLmFicyhfZHggLyBzdGF0ZS50aW1lRGVsdGEpO1xuICAgICAgICBjb25zdCBfdnkgPSBNYXRoLmFicyhfZHkgLyBzdGF0ZS50aW1lRGVsdGEpO1xuICAgICAgICBpZiAoX3Z4ID4gc3Z4ICYmIE1hdGguYWJzKF9teCkgPiBzeCkgc3RhdGUuc3dpcGVbMF0gPSBNYXRoLnNpZ24oX2R4KTtcbiAgICAgICAgaWYgKF92eSA+IHN2eSAmJiBNYXRoLmFicyhfbXkpID4gc3kpIHN0YXRlLnN3aXBlWzFdID0gTWF0aC5zaWduKF9keSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHBvaW50ZXJDbGljayhldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS50YXAgJiYgZXZlbnQuZGV0YWlsID4gMCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuICBzZXR1cFBvaW50ZXIoZXZlbnQpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25zdCBkZXZpY2UgPSBjb25maWcuZGV2aWNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGRldmljZSA9PT0gJ3BvaW50ZXInICYmIGNvbmZpZy5wcmV2ZW50U2Nyb2xsRGVsYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUYXJnZXQgPSAndXYnIGluIGV2ZW50ID8gZXZlbnQuc291cmNlRXZlbnQuY3VycmVudFRhcmdldCA6IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICBpZiAoc3R5bGUudG91Y2hBY3Rpb24gPT09ICdhdXRvJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogVGhlIGRyYWcgdGFyZ2V0IGhhcyBpdHMgXFxgdG91Y2gtYWN0aW9uXFxgIHN0eWxlIHByb3BlcnR5IHNldCB0byBcXGBhdXRvXFxgLiBJdCBpcyByZWNvbW1lbmRlZCB0byBhZGQgXFxgdG91Y2gtYWN0aW9uOiAnbm9uZSdcXGAgc28gdGhhdCB0aGUgZHJhZyBnZXN0dXJlIGJlaGF2ZXMgY29ycmVjdGx5IG9uIHRvdWNoLWVuYWJsZWQgZGV2aWNlcy4gRm9yIG1vcmUgaW5mb3JtYXRpb24gcmVhZCB0aGlzOiBodHRwczovL3VzZS1nZXN0dXJlLm5ldGxpZnkuYXBwL2RvY3MvZXh0cmFzLyN0b3VjaC1hY3Rpb24uXFxuXFxuVGhpcyBtZXNzYWdlIHdpbGwgb25seSBzaG93IGluIGRldmVsb3BtZW50IG1vZGUuIEl0IHdvbid0IGFwcGVhciBpbiBwcm9kdWN0aW9uLiBJZiB0aGlzIGlzIGludGVuZGVkLCB5b3UgY2FuIGlnbm9yZSBpdC5gLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7fVxuICAgIH1cbiAgICBpZiAoY29uZmlnLnBvaW50ZXJMb2NrKSB7XG4gICAgICBldmVudC5jdXJyZW50VGFyZ2V0LnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICAgIH1cbiAgICBpZiAoIWNvbmZpZy5wb2ludGVyQ2FwdHVyZSkge1xuICAgICAgdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csIGRldmljZSwgJ2NoYW5nZScsIHRoaXMucG9pbnRlck1vdmUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgZGV2aWNlLCAnZW5kJywgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgZGV2aWNlLCAnY2FuY2VsJywgdGhpcy5wb2ludGVyVXAuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG4gIHBvaW50ZXJDbGVhbigpIHtcbiAgICBpZiAodGhpcy5jb25maWcucG9pbnRlckxvY2sgJiYgZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50ID09PSB0aGlzLnN0YXRlLmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIGRvY3VtZW50LmV4aXRQb2ludGVyTG9jaygpO1xuICAgIH1cbiAgfVxuICBwcmV2ZW50U2Nyb2xsKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuX3ByZXZlbnRTY3JvbGwgJiYgZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgc2V0dXBTY3JvbGxQcmV2ZW50aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5zdGF0ZS5fcHJldmVudFNjcm9sbCA9IGZhbHNlO1xuICAgIHBlcnNpc3RFdmVudChldmVudCk7XG4gICAgY29uc3QgcmVtb3ZlID0gdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csICd0b3VjaCcsICdjaGFuZ2UnLCB0aGlzLnByZXZlbnRTY3JvbGwuYmluZCh0aGlzKSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLmV2ZW50U3RvcmUuYWRkKHRoaXMuc2hhcmVkQ29uZmlnLndpbmRvdywgJ3RvdWNoJywgJ2VuZCcsIHJlbW92ZSk7XG4gICAgdGhpcy5ldmVudFN0b3JlLmFkZCh0aGlzLnNoYXJlZENvbmZpZy53aW5kb3csICd0b3VjaCcsICdjYW5jZWwnLCByZW1vdmUpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnc3RhcnRQb2ludGVyRHJhZycsIHRoaXMuc3RhcnRQb2ludGVyRHJhZy5iaW5kKHRoaXMpLCB0aGlzLmNvbmZpZy5wcmV2ZW50U2Nyb2xsRGVsYXksIGV2ZW50KTtcbiAgfVxuICBzZXR1cERlbGF5VHJpZ2dlcihldmVudCkge1xuICAgIHRoaXMuc3RhdGUuX2RlbGF5ZWQgPSB0cnVlO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnZHJhZ0RlbGF5JywgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5fc3RlcCA9IFswLCAwXTtcbiAgICAgIHRoaXMuc3RhcnRQb2ludGVyRHJhZyhldmVudCk7XG4gICAgfSwgdGhpcy5jb25maWcuZGVsYXkpO1xuICB9XG4gIGtleURvd24oZXZlbnQpIHtcbiAgICBjb25zdCBkZWx0YUZuID0gS0VZU19ERUxUQV9NQVBbZXZlbnQua2V5XTtcbiAgICBpZiAoZGVsdGFGbikge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgZmFjdG9yID0gZXZlbnQuc2hpZnRLZXkgPyAxMCA6IGV2ZW50LmFsdEtleSA/IDAuMSA6IDE7XG4gICAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICAgIHN0YXRlLl9kZWx0YSA9IGRlbHRhRm4odGhpcy5jb25maWcua2V5Ym9hcmREaXNwbGFjZW1lbnQsIGZhY3Rvcik7XG4gICAgICBzdGF0ZS5fa2V5Ym9hcmRBY3RpdmUgPSB0cnVlO1xuICAgICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfVxuICB9XG4gIGtleVVwKGV2ZW50KSB7XG4gICAgaWYgKCEoZXZlbnQua2V5IGluIEtFWVNfREVMVEFfTUFQKSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2tleWJvYXJkQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmUoKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgY29uc3QgZGV2aWNlID0gdGhpcy5jb25maWcuZGV2aWNlO1xuICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdzdGFydCcsIHRoaXMucG9pbnRlckRvd24uYmluZCh0aGlzKSk7XG4gICAgaWYgKHRoaXMuY29uZmlnLnBvaW50ZXJDYXB0dXJlKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnY2hhbmdlJywgdGhpcy5wb2ludGVyTW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdlbmQnLCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdjYW5jZWwnLCB0aGlzLnBvaW50ZXJVcC5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbignbG9zdFBvaW50ZXJDYXB0dXJlJywgJycsIHRoaXMucG9pbnRlclVwLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcua2V5cykge1xuICAgICAgYmluZEZ1bmN0aW9uKCdrZXknLCAnZG93bicsIHRoaXMua2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbigna2V5JywgJ3VwJywgdGhpcy5rZXlVcC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29uZmlnLmZpbHRlclRhcHMpIHtcbiAgICAgIGJpbmRGdW5jdGlvbignY2xpY2snLCAnJywgdGhpcy5wb2ludGVyQ2xpY2suYmluZCh0aGlzKSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0RXZlbnQoZXZlbnQpIHtcbiAgJ3BlcnNpc3QnIGluIGV2ZW50ICYmIHR5cGVvZiBldmVudC5wZXJzaXN0ID09PSAnZnVuY3Rpb24nICYmIGV2ZW50LnBlcnNpc3QoKTtcbn1cblxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50O1xuZnVuY3Rpb24gc3VwcG9ydHNUb3VjaEV2ZW50cygpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG59XG5mdW5jdGlvbiBpc1RvdWNoU2NyZWVuKCkge1xuICByZXR1cm4gc3VwcG9ydHNUb3VjaEV2ZW50cygpIHx8IGlzQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzUG9pbnRlckV2ZW50cygpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiAnb25wb2ludGVyZG93bicgaW4gd2luZG93O1xufVxuZnVuY3Rpb24gc3VwcG9ydHNQb2ludGVyTG9jaygpIHtcbiAgcmV0dXJuIGlzQnJvd3NlciAmJiAnZXhpdFBvaW50ZXJMb2NrJyBpbiB3aW5kb3cuZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBzdXBwb3J0c0dlc3R1cmVFdmVudHMoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICdjb25zdHJ1Y3RvcicgaW4gR2VzdHVyZUV2ZW50O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBTVVBQT1JUID0ge1xuICBpc0Jyb3dzZXIsXG4gIGdlc3R1cmU6IHN1cHBvcnRzR2VzdHVyZUV2ZW50cygpLFxuICB0b3VjaDogaXNUb3VjaFNjcmVlbigpLFxuICB0b3VjaHNjcmVlbjogaXNUb3VjaFNjcmVlbigpLFxuICBwb2ludGVyOiBzdXBwb3J0c1BvaW50ZXJFdmVudHMoKSxcbiAgcG9pbnRlckxvY2s6IHN1cHBvcnRzUG9pbnRlckxvY2soKVxufTtcblxuY29uc3QgREVGQVVMVF9QUkVWRU5UX1NDUk9MTF9ERUxBWSA9IDI1MDtcbmNvbnN0IERFRkFVTFRfRFJBR19ERUxBWSA9IDE4MDtcbmNvbnN0IERFRkFVTFRfU1dJUEVfVkVMT0NJVFkgPSAwLjU7XG5jb25zdCBERUZBVUxUX1NXSVBFX0RJU1RBTkNFID0gNTA7XG5jb25zdCBERUZBVUxUX1NXSVBFX0RVUkFUSU9OID0gMjUwO1xuY29uc3QgREVGQVVMVF9LRVlCT0FSRF9ESVNQTEFDRU1FTlQgPSAxMDtcbmNvbnN0IERFRkFVTFRfRFJBR19BWElTX1RIUkVTSE9MRCA9IHtcbiAgbW91c2U6IDAsXG4gIHRvdWNoOiAwLFxuICBwZW46IDhcbn07XG5jb25zdCBkcmFnQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29vcmRpbmF0ZXNDb25maWdSZXNvbHZlciksIHt9LCB7XG4gIGRldmljZShfdiwgX2ssIHtcbiAgICBwb2ludGVyOiB7XG4gICAgICB0b3VjaCA9IGZhbHNlLFxuICAgICAgbG9jayA9IGZhbHNlLFxuICAgICAgbW91c2UgPSBmYWxzZVxuICAgIH0gPSB7fVxuICB9KSB7XG4gICAgdGhpcy5wb2ludGVyTG9jayA9IGxvY2sgJiYgU1VQUE9SVC5wb2ludGVyTG9jaztcbiAgICBpZiAoU1VQUE9SVC50b3VjaCAmJiB0b3VjaCkgcmV0dXJuICd0b3VjaCc7XG4gICAgaWYgKHRoaXMucG9pbnRlckxvY2spIHJldHVybiAnbW91c2UnO1xuICAgIGlmIChTVVBQT1JULnBvaW50ZXIgJiYgIW1vdXNlKSByZXR1cm4gJ3BvaW50ZXInO1xuICAgIGlmIChTVVBQT1JULnRvdWNoKSByZXR1cm4gJ3RvdWNoJztcbiAgICByZXR1cm4gJ21vdXNlJztcbiAgfSxcbiAgcHJldmVudFNjcm9sbEF4aXModmFsdWUsIF9rLCB7XG4gICAgcHJldmVudFNjcm9sbFxuICB9KSB7XG4gICAgdGhpcy5wcmV2ZW50U2Nyb2xsRGVsYXkgPSB0eXBlb2YgcHJldmVudFNjcm9sbCA9PT0gJ251bWJlcicgPyBwcmV2ZW50U2Nyb2xsIDogcHJldmVudFNjcm9sbCB8fCBwcmV2ZW50U2Nyb2xsID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPyBERUZBVUxUX1BSRVZFTlRfU0NST0xMX0RFTEFZIDogdW5kZWZpbmVkO1xuICAgIGlmICghU1VQUE9SVC50b3VjaHNjcmVlbiB8fCBwcmV2ZW50U2Nyb2xsID09PSBmYWxzZSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSA6IHByZXZlbnRTY3JvbGwgIT09IHVuZGVmaW5lZCA/ICd5JyA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgcG9pbnRlckNhcHR1cmUoX3YsIF9rLCB7XG4gICAgcG9pbnRlcjoge1xuICAgICAgY2FwdHVyZSA9IHRydWUsXG4gICAgICBidXR0b25zID0gMSxcbiAgICAgIGtleXMgPSB0cnVlXG4gICAgfSA9IHt9XG4gIH0pIHtcbiAgICB0aGlzLnBvaW50ZXJCdXR0b25zID0gYnV0dG9ucztcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHJldHVybiAhdGhpcy5wb2ludGVyTG9jayAmJiB0aGlzLmRldmljZSA9PT0gJ3BvaW50ZXInICYmIGNhcHR1cmU7XG4gIH0sXG4gIHRocmVzaG9sZCh2YWx1ZSwgX2ssIHtcbiAgICBmaWx0ZXJUYXBzID0gZmFsc2UsXG4gICAgdGFwc1RocmVzaG9sZCA9IDMsXG4gICAgYXhpcyA9IHVuZGVmaW5lZFxuICB9KSB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gVi50b1ZlY3Rvcih2YWx1ZSwgZmlsdGVyVGFwcyA/IHRhcHNUaHJlc2hvbGQgOiBheGlzID8gMSA6IDApO1xuICAgIHRoaXMuZmlsdGVyVGFwcyA9IGZpbHRlclRhcHM7XG4gICAgdGhpcy50YXBzVGhyZXNob2xkID0gdGFwc1RocmVzaG9sZDtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xuICB9LFxuICBzd2lwZSh7XG4gICAgdmVsb2NpdHkgPSBERUZBVUxUX1NXSVBFX1ZFTE9DSVRZLFxuICAgIGRpc3RhbmNlID0gREVGQVVMVF9TV0lQRV9ESVNUQU5DRSxcbiAgICBkdXJhdGlvbiA9IERFRkFVTFRfU1dJUEVfRFVSQVRJT05cbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlbG9jaXR5OiB0aGlzLnRyYW5zZm9ybShWLnRvVmVjdG9yKHZlbG9jaXR5KSksXG4gICAgICBkaXN0YW5jZTogdGhpcy50cmFuc2Zvcm0oVi50b1ZlY3RvcihkaXN0YW5jZSkpLFxuICAgICAgZHVyYXRpb25cbiAgICB9O1xuICB9LFxuICBkZWxheSh2YWx1ZSA9IDApIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHJldHVybiBERUZBVUxUX0RSQUdfREVMQVk7XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIGF4aXNUaHJlc2hvbGQodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSByZXR1cm4gREVGQVVMVF9EUkFHX0FYSVNfVEhSRVNIT0xEO1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9EUkFHX0FYSVNfVEhSRVNIT0xEKSwgdmFsdWUpO1xuICB9LFxuICBrZXlib2FyZERpc3BsYWNlbWVudCh2YWx1ZSA9IERFRkFVTFRfS0VZQk9BUkRfRElTUExBQ0VNRU5UKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICBPYmplY3QuYXNzaWduKGRyYWdDb25maWdSZXNvbHZlciwge1xuICAgIHVzZVRvdWNoKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYHVzZVRvdWNoXFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHBvaW50ZXIudG91Y2hcXGAuIFVzZSBpdCBhcyBpbiBcXGB7IHBvaW50ZXI6IHsgdG91Y2g6IHRydWUgfSB9XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIGV4cGVyaW1lbnRhbF9wcmV2ZW50V2luZG93U2Nyb2xsWSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYFtAdXNlLWdlc3R1cmVdOiBcXGBleHBlcmltZW50YWxfcHJldmVudFdpbmRvd1Njcm9sbFlcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgcHJldmVudFNjcm9sbFxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBzd2lwZVZlbG9jaXR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYHN3aXBlVmVsb2NpdHlcXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgc3dpcGUudmVsb2NpdHlcXGAuIFVzZSBpdCBhcyBpbiBcXGB7IHN3aXBlOiB7IHZlbG9jaXR5OiAwLjUgfSB9XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9LFxuICAgIHN3aXBlRGlzdGFuY2UodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgc3dpcGVEaXN0YW5jZVxcYCBvcHRpb24gaGFzIGJlZW4gcmVuYW1lZCB0byBcXGBzd2lwZS5kaXN0YW5jZVxcYC4gVXNlIGl0IGFzIGluIFxcYHsgc3dpcGU6IHsgZGlzdGFuY2U6IDUwIH0gfVxcYC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOYU47XG4gICAgfSxcbiAgICBzd2lwZUR1cmF0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihgW0B1c2UtZ2VzdHVyZV06IFxcYHN3aXBlRHVyYXRpb25cXGAgb3B0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gXFxgc3dpcGUuZHVyYXRpb25cXGAuIFVzZSBpdCBhcyBpbiBcXGB7IHN3aXBlOiB7IGR1cmF0aW9uOiAyNTAgfSB9XFxgLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGFtcFN0YXRlSW50ZXJuYWxNb3ZlbWVudFRvQm91bmRzKHN0YXRlKSB7XG4gIGNvbnN0IFtveCwgb3ldID0gc3RhdGUub3ZlcmZsb3c7XG4gIGNvbnN0IFtkeCwgZHldID0gc3RhdGUuX2RlbHRhO1xuICBjb25zdCBbZGlyeCwgZGlyeV0gPSBzdGF0ZS5fZGlyZWN0aW9uO1xuICBpZiAob3ggPCAwICYmIGR4ID4gMCAmJiBkaXJ4IDwgMCB8fCBveCA+IDAgJiYgZHggPCAwICYmIGRpcnggPiAwKSB7XG4gICAgc3RhdGUuX21vdmVtZW50WzBdID0gc3RhdGUuX21vdmVtZW50Qm91bmRbMF07XG4gIH1cbiAgaWYgKG95IDwgMCAmJiBkeSA+IDAgJiYgZGlyeSA8IDAgfHwgb3kgPiAwICYmIGR5IDwgMCAmJiBkaXJ5ID4gMCkge1xuICAgIHN0YXRlLl9tb3ZlbWVudFsxXSA9IHN0YXRlLl9tb3ZlbWVudEJvdW5kWzFdO1xuICB9XG59XG5cbmNvbnN0IFNDQUxFX0FOR0xFX1JBVElPX0lOVEVOVF9ERUcgPSAzMDtcbmNvbnN0IFBJTkNIX1dIRUVMX1JBVElPID0gMTAwO1xuY2xhc3MgUGluY2hFbmdpbmUgZXh0ZW5kcyBFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICdwaW5jaGluZycpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsaWFzS2V5XCIsICdkYScpO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBbMSwgMF07XG4gICAgdGhpcy5zdGF0ZS5sYXN0T2Zmc2V0ID0gWzEsIDBdO1xuICAgIHRoaXMuc3RhdGUuX3BvaW50ZXJFdmVudHMgPSBuZXcgTWFwKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgc3VwZXIucmVzZXQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgc3RhdGUuX3RvdWNoSWRzID0gW107XG4gICAgc3RhdGUuY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5jYW5jZWwgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHN0YXRlLnR1cm5zID0gMDtcbiAgfVxuICBjb21wdXRlT2Zmc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBtb3ZlbWVudCxcbiAgICAgIGxhc3RPZmZzZXRcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBWLmFkZChtb3ZlbWVudCwgbGFzdE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gWygxICsgbW92ZW1lbnRbMF0pICogbGFzdE9mZnNldFswXSwgbW92ZW1lbnRbMV0gKyBsYXN0T2Zmc2V0WzFdXTtcbiAgICB9XG4gIH1cbiAgY29tcHV0ZU1vdmVtZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldCxcbiAgICAgIGxhc3RPZmZzZXRcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlLm1vdmVtZW50ID0gW29mZnNldFswXSAvIGxhc3RPZmZzZXRbMF0sIG9mZnNldFsxXSAtIGxhc3RPZmZzZXRbMV1dO1xuICB9XG4gIGF4aXNJbnRlbnQoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IFtfbTAsIF9tMV0gPSBzdGF0ZS5fbW92ZW1lbnQ7XG4gICAgaWYgKCFzdGF0ZS5heGlzKSB7XG4gICAgICBjb25zdCBheGlzTW92ZW1lbnREaWZmZXJlbmNlID0gTWF0aC5hYnMoX20wKSAqIFNDQUxFX0FOR0xFX1JBVElPX0lOVEVOVF9ERUcgLSBNYXRoLmFicyhfbTEpO1xuICAgICAgaWYgKGF4aXNNb3ZlbWVudERpZmZlcmVuY2UgPCAwKSBzdGF0ZS5heGlzID0gJ2FuZ2xlJztlbHNlIGlmIChheGlzTW92ZW1lbnREaWZmZXJlbmNlID4gMCkgc3RhdGUuYXhpcyA9ICdzY2FsZSc7XG4gICAgfVxuICB9XG4gIHJlc3RyaWN0VG9BeGlzKHYpIHtcbiAgICBpZiAodGhpcy5jb25maWcubG9ja0RpcmVjdGlvbikge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuYXhpcyA9PT0gJ3NjYWxlJykgdlsxXSA9IDA7ZWxzZSBpZiAodGhpcy5zdGF0ZS5heGlzID09PSAnYW5nbGUnKSB2WzBdID0gMDtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY2FuY2VsZWQpIHJldHVybjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHN0YXRlLmNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfSwgMCk7XG4gIH1cbiAgdG91Y2hTdGFydChldmVudCkge1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGN0cmxUb3VjaElkcyA9IHRoaXMuY3RybC50b3VjaElkcztcbiAgICBpZiAoc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgaWYgKHN0YXRlLl90b3VjaElkcy5ldmVyeShpZCA9PiBjdHJsVG91Y2hJZHMuaGFzKGlkKSkpIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN0cmxUb3VjaElkcy5zaXplIDwgMikgcmV0dXJuO1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHN0YXRlLl90b3VjaElkcyA9IEFycmF5LmZyb20oY3RybFRvdWNoSWRzKS5zbGljZSgwLCAyKTtcbiAgICBjb25zdCBwYXlsb2FkID0gdG91Y2hEaXN0YW5jZUFuZ2xlKGV2ZW50LCBzdGF0ZS5fdG91Y2hJZHMpO1xuICAgIGlmICghcGF5bG9hZCkgcmV0dXJuO1xuICAgIHRoaXMucGluY2hTdGFydChldmVudCwgcGF5bG9hZCk7XG4gIH1cbiAgcG9pbnRlclN0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbnMgIT0gbnVsbCAmJiBldmVudC5idXR0b25zICUgMiAhPT0gMSkgcmV0dXJuO1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IF9wb2ludGVyRXZlbnRzID0gc3RhdGUuX3BvaW50ZXJFdmVudHM7XG4gICAgY29uc3QgY3RybFBvaW50ZXJJZHMgPSB0aGlzLmN0cmwucG9pbnRlcklkcztcbiAgICBpZiAoc3RhdGUuX2FjdGl2ZSkge1xuICAgICAgaWYgKEFycmF5LmZyb20oX3BvaW50ZXJFdmVudHMua2V5cygpKS5ldmVyeShpZCA9PiBjdHJsUG9pbnRlcklkcy5oYXMoaWQpKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoX3BvaW50ZXJFdmVudHMuc2l6ZSA8IDIpIHtcbiAgICAgIF9wb2ludGVyRXZlbnRzLnNldChldmVudC5wb2ludGVySWQsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLl9wb2ludGVyRXZlbnRzLnNpemUgPCAyKSByZXR1cm47XG4gICAgdGhpcy5zdGFydChldmVudCk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGRpc3RhbmNlQW5nbGUoLi4uQXJyYXkuZnJvbShfcG9pbnRlckV2ZW50cy52YWx1ZXMoKSkpO1xuICAgIGlmICghcGF5bG9hZCkgcmV0dXJuO1xuICAgIHRoaXMucGluY2hTdGFydChldmVudCwgcGF5bG9hZCk7XG4gIH1cbiAgcGluY2hTdGFydChldmVudCwgcGF5bG9hZCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5vcmlnaW4gPSBwYXlsb2FkLm9yaWdpbjtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoW3BheWxvYWQuZGlzdGFuY2UsIHBheWxvYWQuYW5nbGVdKTtcbiAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB0b3VjaE1vdmUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSB0b3VjaERpc3RhbmNlQW5nbGUoZXZlbnQsIHRoaXMuc3RhdGUuX3RvdWNoSWRzKTtcbiAgICBpZiAoIXBheWxvYWQpIHJldHVybjtcbiAgICB0aGlzLnBpbmNoTW92ZShldmVudCwgcGF5bG9hZCk7XG4gIH1cbiAgcG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCBfcG9pbnRlckV2ZW50cyA9IHRoaXMuc3RhdGUuX3BvaW50ZXJFdmVudHM7XG4gICAgaWYgKF9wb2ludGVyRXZlbnRzLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBfcG9pbnRlckV2ZW50cy5zZXQoZXZlbnQucG9pbnRlcklkLCBldmVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgY29uc3QgcGF5bG9hZCA9IGRpc3RhbmNlQW5nbGUoLi4uQXJyYXkuZnJvbShfcG9pbnRlckV2ZW50cy52YWx1ZXMoKSkpO1xuICAgIGlmICghcGF5bG9hZCkgcmV0dXJuO1xuICAgIHRoaXMucGluY2hNb3ZlKGV2ZW50LCBwYXlsb2FkKTtcbiAgfVxuICBwaW5jaE1vdmUoZXZlbnQsIHBheWxvYWQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgcHJldl9hID0gc3RhdGUuX3ZhbHVlc1sxXTtcbiAgICBjb25zdCBkZWx0YV9hID0gcGF5bG9hZC5hbmdsZSAtIHByZXZfYTtcbiAgICBsZXQgZGVsdGFfdHVybnMgPSAwO1xuICAgIGlmIChNYXRoLmFicyhkZWx0YV9hKSA+IDI3MCkgZGVsdGFfdHVybnMgKz0gTWF0aC5zaWduKGRlbHRhX2EpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhbcGF5bG9hZC5kaXN0YW5jZSwgcGF5bG9hZC5hbmdsZSAtIDM2MCAqIGRlbHRhX3R1cm5zXSk7XG4gICAgc3RhdGUub3JpZ2luID0gcGF5bG9hZC5vcmlnaW47XG4gICAgc3RhdGUudHVybnMgPSBkZWx0YV90dXJucztcbiAgICBzdGF0ZS5fbW92ZW1lbnQgPSBbc3RhdGUuX3ZhbHVlc1swXSAvIHN0YXRlLl9pbml0aWFsWzBdIC0gMSwgc3RhdGUuX3ZhbHVlc1sxXSAtIHN0YXRlLl9pbml0aWFsWzFdXTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHRvdWNoRW5kKGV2ZW50KSB7XG4gICAgdGhpcy5jdHJsLnNldEV2ZW50SWRzKGV2ZW50KTtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnN0YXRlLl90b3VjaElkcy5zb21lKGlkID0+ICF0aGlzLmN0cmwudG91Y2hJZHMuaGFzKGlkKSkpIHtcbiAgICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH1cbiAgfVxuICBwb2ludGVyRW5kKGV2ZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuY3RybC5zZXRFdmVudElkcyhldmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIGV2ZW50LnRhcmdldC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZXZlbnQucG9pbnRlcklkKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgIGlmIChzdGF0ZS5fcG9pbnRlckV2ZW50cy5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgc3RhdGUuX3BvaW50ZXJFdmVudHMuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgfVxuICAgIGlmICghc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5fcG9pbnRlckV2ZW50cy5zaXplIDwgMikge1xuICAgICAgc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH1cbiAgfVxuICBnZXN0dXJlU3RhcnQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMoW2V2ZW50LnNjYWxlLCBldmVudC5yb3RhdGlvbl0pO1xuICAgIHN0YXRlLm9yaWdpbiA9IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGdlc3R1cmVNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKFtldmVudC5zY2FsZSwgZXZlbnQucm90YXRpb25dKTtcbiAgICBzdGF0ZS5vcmlnaW4gPSBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV07XG4gICAgY29uc3QgX3ByZXZpb3VzTW92ZW1lbnQgPSBzdGF0ZS5fbW92ZW1lbnQ7XG4gICAgc3RhdGUuX21vdmVtZW50ID0gW2V2ZW50LnNjYWxlIC0gMSwgZXZlbnQucm90YXRpb25dO1xuICAgIHN0YXRlLl9kZWx0YSA9IFYuc3ViKHN0YXRlLl9tb3ZlbWVudCwgX3ByZXZpb3VzTW92ZW1lbnQpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgZ2VzdHVyZUVuZChldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB3aGVlbChldmVudCkge1xuICAgIGNvbnN0IG1vZGlmaWVyS2V5ID0gdGhpcy5jb25maWcubW9kaWZpZXJLZXk7XG4gICAgaWYgKG1vZGlmaWVyS2V5ICYmICFldmVudFttb2RpZmllcktleV0pIHJldHVybjtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgdGhpcy53aGVlbFN0YXJ0KGV2ZW50KTtlbHNlIHRoaXMud2hlZWxDaGFuZ2UoZXZlbnQpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnd2hlZWxFbmQnLCB0aGlzLndoZWVsRW5kLmJpbmQodGhpcykpO1xuICB9XG4gIHdoZWVsU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLndoZWVsQ2hhbmdlKGV2ZW50KTtcbiAgfVxuICB3aGVlbENoYW5nZShldmVudCkge1xuICAgIGNvbnN0IGlzUjNmID0gKCd1dicgaW4gZXZlbnQpO1xuICAgIGlmICghaXNSM2YpIHtcbiAgICAgIGlmIChldmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogVG8gcHJvcGVybHkgc3VwcG9ydCB6b29tIG9uIHRyYWNrcGFkcywgdHJ5IHVzaW5nIHRoZSBcXGB0YXJnZXRcXGAgb3B0aW9uLlxcblxcblRoaXMgbWVzc2FnZSB3aWxsIG9ubHkgYXBwZWFyIGluIGRldmVsb3BtZW50IG1vZGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fZGVsdGEgPSBbLXdoZWVsVmFsdWVzKGV2ZW50KVsxXSAvIFBJTkNIX1dIRUVMX1JBVElPICogc3RhdGUub2Zmc2V0WzBdLCAwXTtcbiAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICBjbGFtcFN0YXRlSW50ZXJuYWxNb3ZlbWVudFRvQm91bmRzKHN0YXRlKTtcbiAgICB0aGlzLnN0YXRlLm9yaWdpbiA9IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHdoZWVsRW5kKCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb21wdXRlKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgYmluZChiaW5kRnVuY3Rpb24pIHtcbiAgICBjb25zdCBkZXZpY2UgPSB0aGlzLmNvbmZpZy5kZXZpY2U7XG4gICAgaWYgKCEhZGV2aWNlKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oZGV2aWNlLCAnc3RhcnQnLCB0aGlzW2RldmljZSArICdTdGFydCddLmJpbmQodGhpcykpO1xuICAgICAgYmluZEZ1bmN0aW9uKGRldmljZSwgJ2NoYW5nZScsIHRoaXNbZGV2aWNlICsgJ01vdmUnXS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdlbmQnLCB0aGlzW2RldmljZSArICdFbmQnXS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbihkZXZpY2UsICdjYW5jZWwnLCB0aGlzW2RldmljZSArICdFbmQnXS5iaW5kKHRoaXMpKTtcbiAgICAgIGJpbmRGdW5jdGlvbignbG9zdFBvaW50ZXJDYXB0dXJlJywgJycsIHRoaXNbZGV2aWNlICsgJ0VuZCddLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcucGluY2hPbldoZWVsKSB7XG4gICAgICBiaW5kRnVuY3Rpb24oJ3doZWVsJywgJycsIHRoaXMud2hlZWwuYmluZCh0aGlzKSwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHBpbmNoQ29uZmlnUmVzb2x2ZXIgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgY29tbW9uQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBkZXZpY2UoX3YsIF9rLCB7XG4gICAgc2hhcmVkLFxuICAgIHBvaW50ZXI6IHtcbiAgICAgIHRvdWNoID0gZmFsc2VcbiAgICB9ID0ge31cbiAgfSkge1xuICAgIGNvbnN0IHNoYXJlZENvbmZpZyA9IHNoYXJlZDtcbiAgICBpZiAoc2hhcmVkQ29uZmlnLnRhcmdldCAmJiAhU1VQUE9SVC50b3VjaCAmJiBTVVBQT1JULmdlc3R1cmUpIHJldHVybiAnZ2VzdHVyZSc7XG4gICAgaWYgKFNVUFBPUlQudG91Y2ggJiYgdG91Y2gpIHJldHVybiAndG91Y2gnO1xuICAgIGlmIChTVVBQT1JULnRvdWNoc2NyZWVuKSB7XG4gICAgICBpZiAoU1VQUE9SVC5wb2ludGVyKSByZXR1cm4gJ3BvaW50ZXInO1xuICAgICAgaWYgKFNVUFBPUlQudG91Y2gpIHJldHVybiAndG91Y2gnO1xuICAgIH1cbiAgfSxcbiAgYm91bmRzKF92LCBfaywge1xuICAgIHNjYWxlQm91bmRzID0ge30sXG4gICAgYW5nbGVCb3VuZHMgPSB7fVxuICB9KSB7XG4gICAgY29uc3QgX3NjYWxlQm91bmRzID0gc3RhdGUgPT4ge1xuICAgICAgY29uc3QgRCA9IGFzc2lnbkRlZmF1bHQoY2FsbChzY2FsZUJvdW5kcywgc3RhdGUpLCB7XG4gICAgICAgIG1pbjogLUluZmluaXR5LFxuICAgICAgICBtYXg6IEluZmluaXR5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBbRC5taW4sIEQubWF4XTtcbiAgICB9O1xuICAgIGNvbnN0IF9hbmdsZUJvdW5kcyA9IHN0YXRlID0+IHtcbiAgICAgIGNvbnN0IEEgPSBhc3NpZ25EZWZhdWx0KGNhbGwoYW5nbGVCb3VuZHMsIHN0YXRlKSwge1xuICAgICAgICBtaW46IC1JbmZpbml0eSxcbiAgICAgICAgbWF4OiBJbmZpbml0eVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW0EubWluLCBBLm1heF07XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHNjYWxlQm91bmRzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBhbmdsZUJvdW5kcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIFtfc2NhbGVCb3VuZHMoKSwgX2FuZ2xlQm91bmRzKCldO1xuICAgIHJldHVybiBzdGF0ZSA9PiBbX3NjYWxlQm91bmRzKHN0YXRlKSwgX2FuZ2xlQm91bmRzKHN0YXRlKV07XG4gIH0sXG4gIHRocmVzaG9sZCh2YWx1ZSwgX2ssIGNvbmZpZykge1xuICAgIHRoaXMubG9ja0RpcmVjdGlvbiA9IGNvbmZpZy5heGlzID09PSAnbG9jayc7XG4gICAgY29uc3QgdGhyZXNob2xkID0gVi50b1ZlY3Rvcih2YWx1ZSwgdGhpcy5sb2NrRGlyZWN0aW9uID8gWzAuMSwgM10gOiAwKTtcbiAgICByZXR1cm4gdGhyZXNob2xkO1xuICB9LFxuICBtb2RpZmllcktleSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ2N0cmxLZXknO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgcGluY2hPbldoZWVsKHZhbHVlID0gdHJ1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbmNsYXNzIE1vdmVFbmdpbmUgZXh0ZW5kcyBDb29yZGluYXRlc0VuZ2luZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbmdLZXlcIiwgJ21vdmluZycpO1xuICB9XG4gIG1vdmUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5jb25maWcubW91c2VPbmx5ICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSAnbW91c2UnKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHRoaXMubW92ZVN0YXJ0KGV2ZW50KTtlbHNlIHRoaXMubW92ZUNoYW5nZShldmVudCk7XG4gICAgdGhpcy50aW1lb3V0U3RvcmUuYWRkKCdtb3ZlRW5kJywgdGhpcy5tb3ZlRW5kLmJpbmQodGhpcykpO1xuICB9XG4gIG1vdmVTdGFydChldmVudCkge1xuICAgIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyhwb2ludGVyVmFsdWVzKGV2ZW50KSk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmNvbXB1dGVJbml0aWFsKCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgbW92ZUNoYW5nZShldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSByZXR1cm47XG4gICAgY29uc3QgdmFsdWVzID0gcG9pbnRlclZhbHVlcyhldmVudCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHN0YXRlLl9kZWx0YSA9IFYuc3ViKHZhbHVlcywgc3RhdGUuX3ZhbHVlcyk7XG4gICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgdGhpcy5jb21wdXRlVmFsdWVzKHZhbHVlcyk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBtb3ZlRW5kKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLl9hY3RpdmUpIHJldHVybjtcbiAgICB0aGlzLnN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgYmluZEZ1bmN0aW9uKCdwb2ludGVyJywgJ2NoYW5nZScsIHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICBiaW5kRnVuY3Rpb24oJ3BvaW50ZXInLCAnbGVhdmUnLCB0aGlzLm1vdmVFbmQuYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuY29uc3QgbW92ZUNvbmZpZ1Jlc29sdmVyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBtb3VzZU9ubHk6ICh2YWx1ZSA9IHRydWUpID0+IHZhbHVlXG59KTtcblxuY2xhc3MgU2Nyb2xsRW5naW5lIGV4dGVuZHMgQ29vcmRpbmF0ZXNFbmdpbmUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5nS2V5XCIsICdzY3JvbGxpbmcnKTtcbiAgfVxuICBzY3JvbGwoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgdGhpcy5zdGFydChldmVudCk7XG4gICAgdGhpcy5zY3JvbGxDaGFuZ2UoZXZlbnQpO1xuICAgIHRoaXMudGltZW91dFN0b3JlLmFkZCgnc2Nyb2xsRW5kJywgdGhpcy5zY3JvbGxFbmQuYmluZCh0aGlzKSk7XG4gIH1cbiAgc2Nyb2xsQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHNjcm9sbFZhbHVlcyhldmVudCk7XG4gICAgc3RhdGUuX2RlbHRhID0gVi5zdWIodmFsdWVzLCBzdGF0ZS5fdmFsdWVzKTtcbiAgICBWLmFkZFRvKHN0YXRlLl9tb3ZlbWVudCwgc3RhdGUuX2RlbHRhKTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXModmFsdWVzKTtcbiAgICB0aGlzLmNvbXB1dGUoZXZlbnQpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIHNjcm9sbEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgYmluZEZ1bmN0aW9uKCdzY3JvbGwnLCAnJywgdGhpcy5zY3JvbGwuYmluZCh0aGlzKSk7XG4gIH1cbn1cblxuY29uc3Qgc2Nyb2xsQ29uZmlnUmVzb2x2ZXIgPSBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyO1xuXG5jbGFzcyBXaGVlbEVuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnd2hlZWxpbmcnKTtcbiAgfVxuICB3aGVlbChldmVudCkge1xuICAgIGlmICghdGhpcy5zdGF0ZS5fYWN0aXZlKSB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLndoZWVsQ2hhbmdlKGV2ZW50KTtcbiAgICB0aGlzLnRpbWVvdXRTdG9yZS5hZGQoJ3doZWVsRW5kJywgdGhpcy53aGVlbEVuZC5iaW5kKHRoaXMpKTtcbiAgfVxuICB3aGVlbENoYW5nZShldmVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBzdGF0ZS5fZGVsdGEgPSB3aGVlbFZhbHVlcyhldmVudCk7XG4gICAgVi5hZGRUbyhzdGF0ZS5fbW92ZW1lbnQsIHN0YXRlLl9kZWx0YSk7XG4gICAgY2xhbXBTdGF0ZUludGVybmFsTW92ZW1lbnRUb0JvdW5kcyhzdGF0ZSk7XG4gICAgdGhpcy5jb21wdXRlKGV2ZW50KTtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICB3aGVlbEVuZCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHRoaXMuc3RhdGUuX2FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZSgpO1xuICAgIHRoaXMuZW1pdCgpO1xuICB9XG4gIGJpbmQoYmluZEZ1bmN0aW9uKSB7XG4gICAgYmluZEZ1bmN0aW9uKCd3aGVlbCcsICcnLCB0aGlzLndoZWVsLmJpbmQodGhpcykpO1xuICB9XG59XG5cbmNvbnN0IHdoZWVsQ29uZmlnUmVzb2x2ZXIgPSBjb29yZGluYXRlc0NvbmZpZ1Jlc29sdmVyO1xuXG5jbGFzcyBIb3ZlckVuZ2luZSBleHRlbmRzIENvb3JkaW5hdGVzRW5naW5lIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImluZ0tleVwiLCAnaG92ZXJpbmcnKTtcbiAgfVxuICBlbnRlcihldmVudCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5tb3VzZU9ubHkgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09ICdtb3VzZScpIHJldHVybjtcbiAgICB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICB0aGlzLmNvbXB1dGVWYWx1ZXMocG9pbnRlclZhbHVlcyhldmVudCkpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgdGhpcy5lbWl0KCk7XG4gIH1cbiAgbGVhdmUoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5jb25maWcubW91c2VPbmx5ICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSAnbW91c2UnKSByZXR1cm47XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICghc3RhdGUuX2FjdGl2ZSkgcmV0dXJuO1xuICAgIHN0YXRlLl9hY3RpdmUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBwb2ludGVyVmFsdWVzKGV2ZW50KTtcbiAgICBzdGF0ZS5fbW92ZW1lbnQgPSBzdGF0ZS5fZGVsdGEgPSBWLnN1Yih2YWx1ZXMsIHN0YXRlLl92YWx1ZXMpO1xuICAgIHRoaXMuY29tcHV0ZVZhbHVlcyh2YWx1ZXMpO1xuICAgIHRoaXMuY29tcHV0ZShldmVudCk7XG4gICAgc3RhdGUuZGVsdGEgPSBzdGF0ZS5tb3ZlbWVudDtcbiAgICB0aGlzLmVtaXQoKTtcbiAgfVxuICBiaW5kKGJpbmRGdW5jdGlvbikge1xuICAgIGJpbmRGdW5jdGlvbigncG9pbnRlcicsICdlbnRlcicsIHRoaXMuZW50ZXIuYmluZCh0aGlzKSk7XG4gICAgYmluZEZ1bmN0aW9uKCdwb2ludGVyJywgJ2xlYXZlJywgdGhpcy5sZWF2ZS5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG5jb25zdCBob3ZlckNvbmZpZ1Jlc29sdmVyID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGNvb3JkaW5hdGVzQ29uZmlnUmVzb2x2ZXIpLCB7fSwge1xuICBtb3VzZU9ubHk6ICh2YWx1ZSA9IHRydWUpID0+IHZhbHVlXG59KTtcblxuY29uc3QgRW5naW5lTWFwID0gbmV3IE1hcCgpO1xuY29uc3QgQ29uZmlnUmVzb2x2ZXJNYXAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbihhY3Rpb24pIHtcbiAgRW5naW5lTWFwLnNldChhY3Rpb24ua2V5LCBhY3Rpb24uZW5naW5lKTtcbiAgQ29uZmlnUmVzb2x2ZXJNYXAuc2V0KGFjdGlvbi5rZXksIGFjdGlvbi5yZXNvbHZlcik7XG59XG5jb25zdCBkcmFnQWN0aW9uID0ge1xuICBrZXk6ICdkcmFnJyxcbiAgZW5naW5lOiBEcmFnRW5naW5lLFxuICByZXNvbHZlcjogZHJhZ0NvbmZpZ1Jlc29sdmVyXG59O1xuY29uc3QgaG92ZXJBY3Rpb24gPSB7XG4gIGtleTogJ2hvdmVyJyxcbiAgZW5naW5lOiBIb3ZlckVuZ2luZSxcbiAgcmVzb2x2ZXI6IGhvdmVyQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCBtb3ZlQWN0aW9uID0ge1xuICBrZXk6ICdtb3ZlJyxcbiAgZW5naW5lOiBNb3ZlRW5naW5lLFxuICByZXNvbHZlcjogbW92ZUNvbmZpZ1Jlc29sdmVyXG59O1xuY29uc3QgcGluY2hBY3Rpb24gPSB7XG4gIGtleTogJ3BpbmNoJyxcbiAgZW5naW5lOiBQaW5jaEVuZ2luZSxcbiAgcmVzb2x2ZXI6IHBpbmNoQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCBzY3JvbGxBY3Rpb24gPSB7XG4gIGtleTogJ3Njcm9sbCcsXG4gIGVuZ2luZTogU2Nyb2xsRW5naW5lLFxuICByZXNvbHZlcjogc2Nyb2xsQ29uZmlnUmVzb2x2ZXJcbn07XG5jb25zdCB3aGVlbEFjdGlvbiA9IHtcbiAga2V5OiAnd2hlZWwnLFxuICBlbmdpbmU6IFdoZWVsRW5naW5lLFxuICByZXNvbHZlcjogd2hlZWxDb25maWdSZXNvbHZlclxufTtcblxuZXhwb3J0IHsgQ29uZmlnUmVzb2x2ZXJNYXAgYXMgQywgRW5naW5lTWFwIGFzIEUsIFNVUFBPUlQgYXMgUywgX29iamVjdFNwcmVhZDIgYXMgXywgX2RlZmluZVByb3BlcnR5IGFzIGEsIHRvdWNoSWRzIGFzIGIsIGNoYWluIGFzIGMsIHRvSGFuZGxlclByb3AgYXMgZCwgZHJhZ0FjdGlvbiBhcyBlLCBwaW5jaEFjdGlvbiBhcyBmLCBob3ZlckFjdGlvbiBhcyBoLCBpc1RvdWNoIGFzIGksIG1vdmVBY3Rpb24gYXMgbSwgcGFyc2VQcm9wIGFzIHAsIHJlZ2lzdGVyQWN0aW9uIGFzIHIsIHNjcm9sbEFjdGlvbiBhcyBzLCB0b0RvbUV2ZW50VHlwZSBhcyB0LCB3aGVlbEFjdGlvbiBhcyB3IH07XG4iLCJmdW5jdGlvbiBjbGFtcCh2LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2LCBtYXgpKTtcbn1cbmNvbnN0IFYgPSB7XG4gIHRvVmVjdG9yKHYsIGZhbGxiYWNrKSB7XG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgdiA9IGZhbGxiYWNrO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdiA6IFt2LCB2XTtcbiAgfSxcbiAgYWRkKHYxLCB2Mikge1xuICAgIHJldHVybiBbdjFbMF0gKyB2MlswXSwgdjFbMV0gKyB2MlsxXV07XG4gIH0sXG4gIHN1Yih2MSwgdjIpIHtcbiAgICByZXR1cm4gW3YxWzBdIC0gdjJbMF0sIHYxWzFdIC0gdjJbMV1dO1xuICB9LFxuICBhZGRUbyh2MSwgdjIpIHtcbiAgICB2MVswXSArPSB2MlswXTtcbiAgICB2MVsxXSArPSB2MlsxXTtcbiAgfSxcbiAgc3ViVG8odjEsIHYyKSB7XG4gICAgdjFbMF0gLT0gdjJbMF07XG4gICAgdjFbMV0gLT0gdjJbMV07XG4gIH1cbn07XG5mdW5jdGlvbiBydWJiZXJiYW5kKGRpc3RhbmNlLCBkaW1lbnNpb24sIGNvbnN0YW50KSB7XG4gIGlmIChkaW1lbnNpb24gPT09IDAgfHwgTWF0aC5hYnMoZGltZW5zaW9uKSA9PT0gSW5maW5pdHkpIHJldHVybiBNYXRoLnBvdyhkaXN0YW5jZSwgY29uc3RhbnQgKiA1KTtcbiAgcmV0dXJuIGRpc3RhbmNlICogZGltZW5zaW9uICogY29uc3RhbnQgLyAoZGltZW5zaW9uICsgY29uc3RhbnQgKiBkaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhwb3NpdGlvbiwgbWluLCBtYXgsIGNvbnN0YW50ID0gMC4xNSkge1xuICBpZiAoY29uc3RhbnQgPT09IDApIHJldHVybiBjbGFtcChwb3NpdGlvbiwgbWluLCBtYXgpO1xuICBpZiAocG9zaXRpb24gPCBtaW4pIHJldHVybiAtcnViYmVyYmFuZChtaW4gLSBwb3NpdGlvbiwgbWF4IC0gbWluLCBjb25zdGFudCkgKyBtaW47XG4gIGlmIChwb3NpdGlvbiA+IG1heCkgcmV0dXJuICtydWJiZXJiYW5kKHBvc2l0aW9uIC0gbWF4LCBtYXggLSBtaW4sIGNvbnN0YW50KSArIG1heDtcbiAgcmV0dXJuIHBvc2l0aW9uO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJ1YmJlcmJhbmQoYm91bmRzLCBbVngsIFZ5XSwgW1J4LCBSeV0pIHtcbiAgY29uc3QgW1tYMCwgWDFdLCBbWTAsIFkxXV0gPSBib3VuZHM7XG4gIHJldHVybiBbcnViYmVyYmFuZElmT3V0T2ZCb3VuZHMoVngsIFgwLCBYMSwgUngpLCBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyhWeSwgWTAsIFkxLCBSeSldO1xufVxuXG5leHBvcnQgeyBWLCBjb21wdXRlUnViYmVyYmFuZCBhcyBjLCBydWJiZXJiYW5kSWZPdXRPZkJvdW5kcyBhcyByIH07XG4iLCJpbXBvcnQgeyBTIGFzIFNVUFBPUlQsIEMgYXMgQ29uZmlnUmVzb2x2ZXJNYXAsIF8gYXMgX29iamVjdFNwcmVhZDIsIGEgYXMgX2RlZmluZVByb3BlcnR5LCB0IGFzIHRvRG9tRXZlbnRUeXBlLCBpIGFzIGlzVG91Y2gsIGIgYXMgdG91Y2hJZHMsIEUgYXMgRW5naW5lTWFwLCBjIGFzIGNoYWluLCBwIGFzIHBhcnNlUHJvcCwgZCBhcyB0b0hhbmRsZXJQcm9wIH0gZnJvbSAnLi9hY3Rpb25zLTc2Yjg2ODNlLmVzbS5qcyc7XG5pbXBvcnQgJy4vbWF0aHMtMGFiMzlhZTkuZXNtLmpzJztcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuY29uc3Qgc2hhcmVkQ29uZmlnUmVzb2x2ZXIgPSB7XG4gIHRhcmdldCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuICgpID0+ICdjdXJyZW50JyBpbiB2YWx1ZSA/IHZhbHVlLmN1cnJlbnQgOiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcbiAgZW5hYmxlZCh2YWx1ZSA9IHRydWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIHdpbmRvdyh2YWx1ZSA9IFNVUFBPUlQuaXNCcm93c2VyID8gd2luZG93IDogdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBldmVudE9wdGlvbnMoe1xuICAgIHBhc3NpdmUgPSB0cnVlLFxuICAgIGNhcHR1cmUgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFzc2l2ZSxcbiAgICAgIGNhcHR1cmVcbiAgICB9O1xuICB9LFxuICB0cmFuc2Zvcm0odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbmNvbnN0IF9leGNsdWRlZCA9IFtcInRhcmdldFwiLCBcImV2ZW50T3B0aW9uc1wiLCBcIndpbmRvd1wiLCBcImVuYWJsZWRcIiwgXCJ0cmFuc2Zvcm1cIl07XG5mdW5jdGlvbiByZXNvbHZlV2l0aChjb25maWcgPSB7fSwgcmVzb2x2ZXJzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHJlc29sdmVyXSBvZiBPYmplY3QuZW50cmllcyhyZXNvbHZlcnMpKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcmVzb2x2ZXIpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc3QgciA9IHJlc29sdmVyLmNhbGwocmVzdWx0LCBjb25maWdba2V5XSwga2V5LCBjb25maWcpO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHIpKSByZXN1bHRba2V5XSA9IHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSByZXNvbHZlci5jYWxsKHJlc3VsdCwgY29uZmlnW2tleV0sIGtleSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJlc3VsdFtrZXldID0gcmVzb2x2ZVdpdGgoY29uZmlnW2tleV0sIHJlc29sdmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgaWYgKHJlc29sdmVyKSByZXN1bHRba2V5XSA9IGNvbmZpZ1trZXldO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlKG5ld0NvbmZpZywgZ2VzdHVyZUtleSwgX2NvbmZpZyA9IHt9KSB7XG4gIGNvbnN0IF9yZWYgPSBuZXdDb25maWcsXG4gICAge1xuICAgICAgdGFyZ2V0LFxuICAgICAgZXZlbnRPcHRpb25zLFxuICAgICAgd2luZG93LFxuICAgICAgZW5hYmxlZCxcbiAgICAgIHRyYW5zZm9ybVxuICAgIH0gPSBfcmVmLFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgX2NvbmZpZy5zaGFyZWQgPSByZXNvbHZlV2l0aCh7XG4gICAgdGFyZ2V0LFxuICAgIGV2ZW50T3B0aW9ucyxcbiAgICB3aW5kb3csXG4gICAgZW5hYmxlZCxcbiAgICB0cmFuc2Zvcm1cbiAgfSwgc2hhcmVkQ29uZmlnUmVzb2x2ZXIpO1xuICBpZiAoZ2VzdHVyZUtleSkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gQ29uZmlnUmVzb2x2ZXJNYXAuZ2V0KGdlc3R1cmVLZXkpO1xuICAgIF9jb25maWdbZ2VzdHVyZUtleV0gPSByZXNvbHZlV2l0aChfb2JqZWN0U3ByZWFkMih7XG4gICAgICBzaGFyZWQ6IF9jb25maWcuc2hhcmVkXG4gICAgfSwgcmVzdCksIHJlc29sdmVyKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN0KSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IENvbmZpZ1Jlc29sdmVyTWFwLmdldChrZXkpO1xuICAgICAgaWYgKHJlc29sdmVyKSB7XG4gICAgICAgIF9jb25maWdba2V5XSA9IHJlc29sdmVXaXRoKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzaGFyZWQ6IF9jb25maWcuc2hhcmVkXG4gICAgICAgIH0sIHJlc3Rba2V5XSksIHJlc29sdmVyKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgaWYgKCFbJ2RyYWcnLCAncGluY2gnLCAnc2Nyb2xsJywgJ3doZWVsJywgJ21vdmUnLCAnaG92ZXInXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ2RvbVRhcmdldCcpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBbQHVzZS1nZXN0dXJlXTogXFxgZG9tVGFyZ2V0XFxgIG9wdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIFxcYHRhcmdldFxcYC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS53YXJuKGBbQHVzZS1nZXN0dXJlXTogVW5rbm93biBjb25maWcga2V5IFxcYCR7a2V5fVxcYCB3YXMgdXNlZC4gUGxlYXNlIHJlYWQgdGhlIGRvY3VtZW50YXRpb24gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jb25maWc7XG59XG5cbmNsYXNzIEV2ZW50U3RvcmUge1xuICBjb25zdHJ1Y3RvcihjdHJsLCBnZXN0dXJlS2V5KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2xpc3RlbmVyc1wiLCBuZXcgU2V0KCkpO1xuICAgIHRoaXMuX2N0cmwgPSBjdHJsO1xuICAgIHRoaXMuX2dlc3R1cmVLZXkgPSBnZXN0dXJlS2V5O1xuICB9XG4gIGFkZChlbGVtZW50LCBkZXZpY2UsIGFjdGlvbiwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCB0eXBlID0gdG9Eb21FdmVudFR5cGUoZGV2aWNlLCBhY3Rpb24pO1xuICAgIGNvbnN0IF9vcHRpb25zID0gdGhpcy5fZ2VzdHVyZUtleSA/IHRoaXMuX2N0cmwuY29uZmlnW3RoaXMuX2dlc3R1cmVLZXldLmV2ZW50T3B0aW9ucyA6IHt9O1xuICAgIGNvbnN0IGV2ZW50T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBldmVudE9wdGlvbnMpO1xuICAgIGNvbnN0IHJlbW92ZSA9ICgpID0+IHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBldmVudE9wdGlvbnMpO1xuICAgICAgbGlzdGVuZXJzLmRlbGV0ZShyZW1vdmUpO1xuICAgIH07XG4gICAgbGlzdGVuZXJzLmFkZChyZW1vdmUpO1xuICAgIHJldHVybiByZW1vdmU7XG4gIH1cbiAgY2xlYW4oKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2gocmVtb3ZlID0+IHJlbW92ZSgpKTtcbiAgICB0aGlzLl9saXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuXG5jbGFzcyBUaW1lb3V0U3RvcmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGltZW91dHNcIiwgbmV3IE1hcCgpKTtcbiAgfVxuICBhZGQoa2V5LCBjYWxsYmFjaywgbXMgPSAxNDAsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLnJlbW92ZShrZXkpO1xuICAgIHRoaXMuX3RpbWVvdXRzLnNldChrZXksIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCBtcywgLi4uYXJncykpO1xuICB9XG4gIHJlbW92ZShrZXkpIHtcbiAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5fdGltZW91dHMuZ2V0KGtleSk7XG4gICAgaWYgKHRpbWVvdXQpIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gIH1cbiAgY2xlYW4oKSB7XG4gICAgdGhpcy5fdGltZW91dHMuZm9yRWFjaCh0aW1lb3V0ID0+IHZvaWQgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgdGhpcy5fdGltZW91dHMuY2xlYXIoKTtcbiAgfVxufVxuXG5jbGFzcyBDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoaGFuZGxlcnMpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXN0dXJlc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90YXJnZXRFdmVudFN0b3JlXCIsIG5ldyBFdmVudFN0b3JlKHRoaXMpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXN0dXJlRXZlbnRTdG9yZXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlc3R1cmVUaW1lb3V0U3RvcmVzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYW5kbGVyc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uZmlnXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb2ludGVySWRzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG91Y2hJZHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICBzaGFyZWQ6IHtcbiAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICBtZXRhS2V5OiBmYWxzZSxcbiAgICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICAgIGFsdEtleTogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXNvbHZlR2VzdHVyZXModGhpcywgaGFuZGxlcnMpO1xuICB9XG4gIHNldEV2ZW50SWRzKGV2ZW50KSB7XG4gICAgaWYgKGlzVG91Y2goZXZlbnQpKSB7XG4gICAgICB0aGlzLnRvdWNoSWRzID0gbmV3IFNldCh0b3VjaElkcyhldmVudCkpO1xuICAgICAgcmV0dXJuIHRoaXMudG91Y2hJZHM7XG4gICAgfSBlbHNlIGlmICgncG9pbnRlcklkJyBpbiBldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwb2ludGVydXAnIHx8IGV2ZW50LnR5cGUgPT09ICdwb2ludGVyY2FuY2VsJykgdGhpcy5wb2ludGVySWRzLmRlbGV0ZShldmVudC5wb2ludGVySWQpO2Vsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdwb2ludGVyZG93bicpIHRoaXMucG9pbnRlcklkcy5hZGQoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50ZXJJZHM7XG4gICAgfVxuICB9XG4gIGFwcGx5SGFuZGxlcnMoaGFuZGxlcnMsIG5hdGl2ZUhhbmRsZXJzKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIHRoaXMubmF0aXZlSGFuZGxlcnMgPSBuYXRpdmVIYW5kbGVycztcbiAgfVxuICBhcHBseUNvbmZpZyhjb25maWcsIGdlc3R1cmVLZXkpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHBhcnNlKGNvbmZpZywgZ2VzdHVyZUtleSwgdGhpcy5jb25maWcpO1xuICB9XG4gIGNsZWFuKCkge1xuICAgIHRoaXMuX3RhcmdldEV2ZW50U3RvcmUuY2xlYW4oKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmdlc3R1cmVzKSB7XG4gICAgICB0aGlzLmdlc3R1cmVFdmVudFN0b3Jlc1trZXldLmNsZWFuKCk7XG4gICAgICB0aGlzLmdlc3R1cmVUaW1lb3V0U3RvcmVzW2tleV0uY2xlYW4oKTtcbiAgICB9XG4gIH1cbiAgZWZmZWN0KCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5zaGFyZWQudGFyZ2V0KSB0aGlzLmJpbmQoKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5fdGFyZ2V0RXZlbnRTdG9yZS5jbGVhbigpO1xuICB9XG4gIGJpbmQoLi4uYXJncykge1xuICAgIGNvbnN0IHNoYXJlZENvbmZpZyA9IHRoaXMuY29uZmlnLnNoYXJlZDtcbiAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgIGxldCB0YXJnZXQ7XG4gICAgaWYgKHNoYXJlZENvbmZpZy50YXJnZXQpIHtcbiAgICAgIHRhcmdldCA9IHNoYXJlZENvbmZpZy50YXJnZXQoKTtcbiAgICAgIGlmICghdGFyZ2V0KSByZXR1cm47XG4gICAgfVxuICAgIGlmIChzaGFyZWRDb25maWcuZW5hYmxlZCkge1xuICAgICAgZm9yIChjb25zdCBnZXN0dXJlS2V5IG9mIHRoaXMuZ2VzdHVyZXMpIHtcbiAgICAgICAgY29uc3QgZ2VzdHVyZUNvbmZpZyA9IHRoaXMuY29uZmlnW2dlc3R1cmVLZXldO1xuICAgICAgICBjb25zdCBiaW5kRnVuY3Rpb24gPSBiaW5kVG9Qcm9wcyhwcm9wcywgZ2VzdHVyZUNvbmZpZy5ldmVudE9wdGlvbnMsICEhdGFyZ2V0KTtcbiAgICAgICAgaWYgKGdlc3R1cmVDb25maWcuZW5hYmxlZCkge1xuICAgICAgICAgIGNvbnN0IEVuZ2luZSA9IEVuZ2luZU1hcC5nZXQoZ2VzdHVyZUtleSk7XG4gICAgICAgICAgbmV3IEVuZ2luZSh0aGlzLCBhcmdzLCBnZXN0dXJlS2V5KS5iaW5kKGJpbmRGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5hdGl2ZUJpbmRGdW5jdGlvbiA9IGJpbmRUb1Byb3BzKHByb3BzLCBzaGFyZWRDb25maWcuZXZlbnRPcHRpb25zLCAhIXRhcmdldCk7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50S2V5IGluIHRoaXMubmF0aXZlSGFuZGxlcnMpIHtcbiAgICAgICAgbmF0aXZlQmluZEZ1bmN0aW9uKGV2ZW50S2V5LCAnJywgZXZlbnQgPT4gdGhpcy5uYXRpdmVIYW5kbGVyc1tldmVudEtleV0oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuc3RhdGUuc2hhcmVkKSwge30sIHtcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBhcmdzXG4gICAgICAgIH0pKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBoYW5kbGVyUHJvcCBpbiBwcm9wcykge1xuICAgICAgcHJvcHNbaGFuZGxlclByb3BdID0gY2hhaW4oLi4ucHJvcHNbaGFuZGxlclByb3BdKTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXQpIHJldHVybiBwcm9wcztcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXJQcm9wIGluIHByb3BzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRldmljZSxcbiAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgcGFzc2l2ZVxuICAgICAgfSA9IHBhcnNlUHJvcChoYW5kbGVyUHJvcCk7XG4gICAgICB0aGlzLl90YXJnZXRFdmVudFN0b3JlLmFkZCh0YXJnZXQsIGRldmljZSwgJycsIHByb3BzW2hhbmRsZXJQcm9wXSwge1xuICAgICAgICBjYXB0dXJlLFxuICAgICAgICBwYXNzaXZlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldHVwR2VzdHVyZShjdHJsLCBnZXN0dXJlS2V5KSB7XG4gIGN0cmwuZ2VzdHVyZXMuYWRkKGdlc3R1cmVLZXkpO1xuICBjdHJsLmdlc3R1cmVFdmVudFN0b3Jlc1tnZXN0dXJlS2V5XSA9IG5ldyBFdmVudFN0b3JlKGN0cmwsIGdlc3R1cmVLZXkpO1xuICBjdHJsLmdlc3R1cmVUaW1lb3V0U3RvcmVzW2dlc3R1cmVLZXldID0gbmV3IFRpbWVvdXRTdG9yZSgpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUdlc3R1cmVzKGN0cmwsIGludGVybmFsSGFuZGxlcnMpIHtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMuZHJhZykgc2V0dXBHZXN0dXJlKGN0cmwsICdkcmFnJyk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLndoZWVsKSBzZXR1cEdlc3R1cmUoY3RybCwgJ3doZWVsJyk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLnNjcm9sbCkgc2V0dXBHZXN0dXJlKGN0cmwsICdzY3JvbGwnKTtcbiAgaWYgKGludGVybmFsSGFuZGxlcnMubW92ZSkgc2V0dXBHZXN0dXJlKGN0cmwsICdtb3ZlJyk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLnBpbmNoKSBzZXR1cEdlc3R1cmUoY3RybCwgJ3BpbmNoJyk7XG4gIGlmIChpbnRlcm5hbEhhbmRsZXJzLmhvdmVyKSBzZXR1cEdlc3R1cmUoY3RybCwgJ2hvdmVyJyk7XG59XG5jb25zdCBiaW5kVG9Qcm9wcyA9IChwcm9wcywgZXZlbnRPcHRpb25zLCB3aXRoUGFzc2l2ZU9wdGlvbikgPT4gKGRldmljZSwgYWN0aW9uLCBoYW5kbGVyLCBvcHRpb25zID0ge30sIGlzTmF0aXZlID0gZmFsc2UpID0+IHtcbiAgdmFyIF9vcHRpb25zJGNhcHR1cmUsIF9vcHRpb25zJHBhc3NpdmU7XG4gIGNvbnN0IGNhcHR1cmUgPSAoX29wdGlvbnMkY2FwdHVyZSA9IG9wdGlvbnMuY2FwdHVyZSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FwdHVyZSAhPT0gdm9pZCAwID8gX29wdGlvbnMkY2FwdHVyZSA6IGV2ZW50T3B0aW9ucy5jYXB0dXJlO1xuICBjb25zdCBwYXNzaXZlID0gKF9vcHRpb25zJHBhc3NpdmUgPSBvcHRpb25zLnBhc3NpdmUpICE9PSBudWxsICYmIF9vcHRpb25zJHBhc3NpdmUgIT09IHZvaWQgMCA/IF9vcHRpb25zJHBhc3NpdmUgOiBldmVudE9wdGlvbnMucGFzc2l2ZTtcbiAgbGV0IGhhbmRsZXJQcm9wID0gaXNOYXRpdmUgPyBkZXZpY2UgOiB0b0hhbmRsZXJQcm9wKGRldmljZSwgYWN0aW9uLCBjYXB0dXJlKTtcbiAgaWYgKHdpdGhQYXNzaXZlT3B0aW9uICYmIHBhc3NpdmUpIGhhbmRsZXJQcm9wICs9ICdQYXNzaXZlJztcbiAgcHJvcHNbaGFuZGxlclByb3BdID0gcHJvcHNbaGFuZGxlclByb3BdIHx8IFtdO1xuICBwcm9wc1toYW5kbGVyUHJvcF0ucHVzaChoYW5kbGVyKTtcbn07XG5cbmNvbnN0IFJFX05PVF9OQVRJVkUgPSAvXm9uKERyYWd8V2hlZWx8U2Nyb2xsfE1vdmV8UGluY2h8SG92ZXIpLztcbmZ1bmN0aW9uIHNvcnRIYW5kbGVycyhfaGFuZGxlcnMpIHtcbiAgY29uc3QgbmF0aXZlID0ge307XG4gIGNvbnN0IGhhbmRsZXJzID0ge307XG4gIGNvbnN0IGFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gIGZvciAobGV0IGtleSBpbiBfaGFuZGxlcnMpIHtcbiAgICBpZiAoUkVfTk9UX05BVElWRS50ZXN0KGtleSkpIHtcbiAgICAgIGFjdGlvbnMuYWRkKFJlZ0V4cC5sYXN0TWF0Y2gpO1xuICAgICAgaGFuZGxlcnNba2V5XSA9IF9oYW5kbGVyc1trZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYXRpdmVba2V5XSA9IF9oYW5kbGVyc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2hhbmRsZXJzLCBuYXRpdmUsIGFjdGlvbnNdO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCBoYW5kbGVyS2V5LCBrZXksIGludGVybmFsSGFuZGxlcnMsIGNvbmZpZykge1xuICBpZiAoIWFjdGlvbnMuaGFzKGhhbmRsZXJLZXkpKSByZXR1cm47XG4gIGlmICghRW5naW5lTWFwLmhhcyhrZXkpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtAdXNlLWdlc3R1cmVdOiBZb3UndmUgY3JlYXRlZCBhIGN1c3RvbSBoYW5kbGVyIHRoYXQgdGhhdCB1c2VzIHRoZSBcXGAke2tleX1cXGAgZ2VzdHVyZSBidXQgaXNuJ3QgcHJvcGVybHkgY29uZmlndXJlZC5cXG5cXG5QbGVhc2UgYWRkIFxcYCR7a2V5fUFjdGlvblxcYCB3aGVuIGNyZWF0aW5nIHlvdXIgaGFuZGxlci5gKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHN0YXJ0S2V5ID0gaGFuZGxlcktleSArICdTdGFydCc7XG4gIGNvbnN0IGVuZEtleSA9IGhhbmRsZXJLZXkgKyAnRW5kJztcbiAgY29uc3QgZm4gPSBzdGF0ZSA9PiB7XG4gICAgbGV0IG1lbW8gPSB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLmZpcnN0ICYmIHN0YXJ0S2V5IGluIGhhbmRsZXJzKSBoYW5kbGVyc1tzdGFydEtleV0oc3RhdGUpO1xuICAgIGlmIChoYW5kbGVyS2V5IGluIGhhbmRsZXJzKSBtZW1vID0gaGFuZGxlcnNbaGFuZGxlcktleV0oc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5sYXN0ICYmIGVuZEtleSBpbiBoYW5kbGVycykgaGFuZGxlcnNbZW5kS2V5XShzdGF0ZSk7XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG4gIGludGVybmFsSGFuZGxlcnNba2V5XSA9IGZuO1xuICBjb25maWdba2V5XSA9IGNvbmZpZ1trZXldIHx8IHt9O1xufVxuZnVuY3Rpb24gcGFyc2VNZXJnZWRIYW5kbGVycyhtZXJnZWRIYW5kbGVycywgbWVyZ2VkQ29uZmlnKSB7XG4gIGNvbnN0IFtoYW5kbGVycywgbmF0aXZlSGFuZGxlcnMsIGFjdGlvbnNdID0gc29ydEhhbmRsZXJzKG1lcmdlZEhhbmRsZXJzKTtcbiAgY29uc3QgaW50ZXJuYWxIYW5kbGVycyA9IHt9O1xuICByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsICdvbkRyYWcnLCAnZHJhZycsIGludGVybmFsSGFuZGxlcnMsIG1lcmdlZENvbmZpZyk7XG4gIHJlZ2lzdGVyR2VzdHVyZShhY3Rpb25zLCBoYW5kbGVycywgJ29uV2hlZWwnLCAnd2hlZWwnLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsICdvblNjcm9sbCcsICdzY3JvbGwnLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsICdvblBpbmNoJywgJ3BpbmNoJywgaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnKTtcbiAgcmVnaXN0ZXJHZXN0dXJlKGFjdGlvbnMsIGhhbmRsZXJzLCAnb25Nb3ZlJywgJ21vdmUnLCBpbnRlcm5hbEhhbmRsZXJzLCBtZXJnZWRDb25maWcpO1xuICByZWdpc3Rlckdlc3R1cmUoYWN0aW9ucywgaGFuZGxlcnMsICdvbkhvdmVyJywgJ2hvdmVyJywgaW50ZXJuYWxIYW5kbGVycywgbWVyZ2VkQ29uZmlnKTtcbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyczogaW50ZXJuYWxIYW5kbGVycyxcbiAgICBjb25maWc6IG1lcmdlZENvbmZpZyxcbiAgICBuYXRpdmVIYW5kbGVyc1xuICB9O1xufVxuXG5leHBvcnQgeyBDb250cm9sbGVyLCBwYXJzZU1lcmdlZEhhbmRsZXJzIH07XG4iLCJcbiIsImV4cG9ydCB7IHIgYXMgcnViYmVyYmFuZElmT3V0T2ZCb3VuZHMgfSBmcm9tICcuLi8uLi9kaXN0L21hdGhzLTBhYjM5YWU5LmVzbS5qcyc7XG4iLCJpbXBvcnQgeyByZWdpc3RlckFjdGlvbiwgZHJhZ0FjdGlvbiwgcGluY2hBY3Rpb24sIHdoZWVsQWN0aW9uLCBzY3JvbGxBY3Rpb24sIG1vdmVBY3Rpb24sIGhvdmVyQWN0aW9uIH0gZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUvYWN0aW9ucyc7XG5leHBvcnQgKiBmcm9tICdAdXNlLWdlc3R1cmUvY29yZS9hY3Rpb25zJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb250cm9sbGVyLCBwYXJzZU1lcmdlZEhhbmRsZXJzIH0gZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUnO1xuZXhwb3J0ICogZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUvdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnQHVzZS1nZXN0dXJlL2NvcmUvdHlwZXMnO1xuXG5mdW5jdGlvbiB1c2VSZWNvZ25pemVycyhoYW5kbGVycywgY29uZmlnID0ge30sIGdlc3R1cmVLZXksIG5hdGl2ZUhhbmRsZXJzKSB7XG4gIGNvbnN0IGN0cmwgPSBSZWFjdC51c2VNZW1vKCgpID0+IG5ldyBDb250cm9sbGVyKGhhbmRsZXJzKSwgW10pO1xuICBjdHJsLmFwcGx5SGFuZGxlcnMoaGFuZGxlcnMsIG5hdGl2ZUhhbmRsZXJzKTtcbiAgY3RybC5hcHBseUNvbmZpZyhjb25maWcsIGdlc3R1cmVLZXkpO1xuICBSZWFjdC51c2VFZmZlY3QoY3RybC5lZmZlY3QuYmluZChjdHJsKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGN0cmwuY2xlYW4uYmluZChjdHJsKTtcbiAgfSwgW10pO1xuICBpZiAoY29uZmlnLnRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGN0cmwuYmluZC5iaW5kKGN0cmwpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHVzZURyYWcoaGFuZGxlciwgY29uZmlnKSB7XG4gIHJlZ2lzdGVyQWN0aW9uKGRyYWdBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIGRyYWc6IGhhbmRsZXJcbiAgfSwgY29uZmlnIHx8IHt9LCAnZHJhZycpO1xufVxuXG5mdW5jdGlvbiB1c2VQaW5jaChoYW5kbGVyLCBjb25maWcpIHtcbiAgcmVnaXN0ZXJBY3Rpb24ocGluY2hBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHBpbmNoOiBoYW5kbGVyXG4gIH0sIGNvbmZpZyB8fCB7fSwgJ3BpbmNoJyk7XG59XG5cbmZ1bmN0aW9uIHVzZVdoZWVsKGhhbmRsZXIsIGNvbmZpZykge1xuICByZWdpc3RlckFjdGlvbih3aGVlbEFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgd2hlZWw6IGhhbmRsZXJcbiAgfSwgY29uZmlnIHx8IHt9LCAnd2hlZWwnKTtcbn1cblxuZnVuY3Rpb24gdXNlU2Nyb2xsKGhhbmRsZXIsIGNvbmZpZykge1xuICByZWdpc3RlckFjdGlvbihzY3JvbGxBY3Rpb24pO1xuICByZXR1cm4gdXNlUmVjb2duaXplcnMoe1xuICAgIHNjcm9sbDogaGFuZGxlclxuICB9LCBjb25maWcgfHwge30sICdzY3JvbGwnKTtcbn1cblxuZnVuY3Rpb24gdXNlTW92ZShoYW5kbGVyLCBjb25maWcpIHtcbiAgcmVnaXN0ZXJBY3Rpb24obW92ZUFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgbW92ZTogaGFuZGxlclxuICB9LCBjb25maWcgfHwge30sICdtb3ZlJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUhvdmVyKGhhbmRsZXIsIGNvbmZpZykge1xuICByZWdpc3RlckFjdGlvbihob3ZlckFjdGlvbik7XG4gIHJldHVybiB1c2VSZWNvZ25pemVycyh7XG4gICAgaG92ZXI6IGhhbmRsZXJcbiAgfSwgY29uZmlnIHx8IHt9LCAnaG92ZXInKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXNlR2VzdHVyZShhY3Rpb25zKSB7XG4gIGFjdGlvbnMuZm9yRWFjaChyZWdpc3RlckFjdGlvbik7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VHZXN0dXJlKF9oYW5kbGVycywgX2NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhhbmRsZXJzLFxuICAgICAgbmF0aXZlSGFuZGxlcnMsXG4gICAgICBjb25maWdcbiAgICB9ID0gcGFyc2VNZXJnZWRIYW5kbGVycyhfaGFuZGxlcnMsIF9jb25maWcgfHwge30pO1xuICAgIHJldHVybiB1c2VSZWNvZ25pemVycyhoYW5kbGVycywgY29uZmlnLCB1bmRlZmluZWQsIG5hdGl2ZUhhbmRsZXJzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlR2VzdHVyZShoYW5kbGVycywgY29uZmlnKSB7XG4gIGNvbnN0IGhvb2sgPSBjcmVhdGVVc2VHZXN0dXJlKFtkcmFnQWN0aW9uLCBwaW5jaEFjdGlvbiwgc2Nyb2xsQWN0aW9uLCB3aGVlbEFjdGlvbiwgbW92ZUFjdGlvbiwgaG92ZXJBY3Rpb25dKTtcbiAgcmV0dXJuIGhvb2soaGFuZGxlcnMsIGNvbmZpZyB8fCB7fSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVVzZUdlc3R1cmUsIHVzZURyYWcsIHVzZUdlc3R1cmUsIHVzZUhvdmVyLCB1c2VNb3ZlLCB1c2VQaW5jaCwgdXNlU2Nyb2xsLCB1c2VXaGVlbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9